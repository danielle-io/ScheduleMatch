import React, { useState, useEffect } from "react";
import { css, jsx } from "@emotion/core";

import * as connections from "../../helpers/connections";
import {
    buildNewRules,
    buildStaticSlots,
    checkSlotAvailability,
    generateEmptyRulesSlots
} from "../../helpers/slots.rules";
import {
    parseExtras,
    parseAccountOptions,
    buildRuleTemplate
} from "../../helpers/utils.AvailabilityRules";
import { parseStyleOptions } from "../../helpers/theming";
import { globals } from "../../styles/utils";
import { i18nConstructor } from "../../helpers/i18n";
import { logConstructor } from "../../helpers/logging";

import Calendars from "./Calendars";
import Container from "../generic/Container";
import Error from "../generic/Error";
import Footer from "./Footer";
import Week from "./Week";

export const LoggingContext = React.createContext();
export const ExtrasContext = React.createContext();
export const CalendarContext = React.createContext();
export const I18nContext = React.createContext();
export const RulesContext = React.createContext();
export const SlotsContext = React.createContext();
export const StaticSlotsContext = React.createContext();
export const StatusContext = React.createContext();
export const ThemeContext = React.createContext();

const AvailabilityRules = ({ options }) => {
    const [log, setLog] = useState(
        logConstructor(options.config.logs, "Availability Rules")
    );
    const [account, setAccount] = useState(parseAccountOptions(options));
    const [calendars, setCalendars] = useState({ all: [], active: [] });
    const [rules, setRules] = useState([]);
    const [i18n, setI18n] = useState(
        i18nConstructor(
            "availability_rules",
            options.locale,
            options.translations
        )
    );
    const [status, setStatus] = useState({
        loading: true,
        error: false,
        saving: false,
        saved: false,
        savedSuccess: false,
        locale: options.locale,
        tzid: options.tzid,
        ruleSaved: options.callback ? options.callback : cb => {},
        startDay: options.config.startDay
    });
    const [extras, setExtras] = useState(parseExtras(options));
    const rawSlots = generateEmptyRulesSlots(extras.limits, status.startDay);
    const [slots, setSlots] = useState(rawSlots);
    const slotsValue = React.useMemo(() => {
        return {
            slots,
            setSlots
        };
    }, [slots]);
    const [staticSlots, setStaticSlots] = useState(
        buildStaticSlots(rawSlots, extras.limits.slotsPerDay)
    );
    const [theme, setTheme] = useState({
        ...parseStyleOptions(options.styles, "AvailabilityViewer"),
        sizes: {
            labelWidth: 60,
            columnWidth: 100
        }
    });

    useEffect(() => {
        const newSlots = generateEmptyRulesSlots(
            extras.limits,
            status.startDay
        );
        setStaticSlots(buildStaticSlots(newSlots, extras.limits.slotsPerDay));

        const newHydratedSlots = checkSlotAvailability(rules, newSlots);
        setSlots(newHydratedSlots);
    }, [extras]);

    useEffect(() => {
        // Query the API for rules and calendars, but don't do anything until
        // we've heard back from both.
        Promise.all([
            connections.getAvailabilityRules(
                options.token,
                options.domains.apiDomain,
                account.availability_rule_id,
                `AvailabilityRules`,
                options.demo
            ),
            connections.getCalendars(
                options.token,
                options.domains.apiDomain,
                options.demo
            )
        ])
            .then(res => {
                const isNewRule = res[0].type === 404;
                const rulesResponse = isNewRule
                    ? buildRuleTemplate(options)
                    : res[0];

                const calsResponse = res[1];

                setRules(rulesResponse.availability_rule.weekly_periods);

                const hydratedSlots = checkSlotAvailability(
                    rulesResponse.availability_rule.weekly_periods,
                    slots
                );
                setSlots(hydratedSlots);
                setExtras({
                    ...extras,
                    limits: {
                        ...extras.limits,
                        tzid: rulesResponse.availability_rule.tzid
                    }
                });

                setCalendars({
                    active: rulesResponse.availability_rule.calendar_ids || [],
                    all: calsResponse
                });

                setStatus({
                    ...status,
                    loading: false,
                    calLoading: false
                });
            })
            .catch(error => {
                const errorMessage = error.message ? error.message : error;
                const errorOutput = {};
                if (error.docsSlug) {
                    errorOutput.docsSlug = error.docsSlug;
                }
                log.error(errorMessage, errorOutput);
                setStatus({
                    ...status,
                    loading: false,
                    error: error
                });
            });
    }, []);

    useEffect(() => {
        // When the rules are marked as "saved", we show a notification.
        // This timeout hides that notification after 6 seconds
        if (status.saved) {
            setTimeout(() => {
                setStatus({ ...status, saved: false });
            }, 6000);
        }
    }, [status]);

    const generateRules = () => {
        const newRules = buildNewRules(slots);

        setRules(newRules);
        const rulesRequest = { ...account, weekly_periods: newRules };

        let tempStatus = status;

        if (calendars.active.length > 0) {
            rulesRequest.calendar_ids = calendars.active;
        }

        if (options.demo) {
            log.info("In demo mode, so not saving rules", {
                errorObject: rulesRequest
            });
            const callbackContent = {
                notification: {
                    type: "availability_rule_saved"
                },
                availability_rule: rulesRequest
            };
            status.ruleSaved(callbackContent);
            return;
        }

        if (rulesRequest) {
            tempStatus = {
                ...tempStatus,
                saving: true,
                savedSuccess: false
            };
            setStatus(tempStatus);
            connections
                .setAvailabilityRules(
                    options.token,
                    options.domains.apiDomain,
                    rulesRequest,
                    `AvailabilityRules`,
                    options.demo
                )
                .then(res => {
                    if (res.errors) {
                        const errorOutput = {};
                        if (error.docsSlug) {
                            errorOutput.docsSlug = error.docsSlug;
                        }
                        if (error.errorObject) {
                            errorOutput.errorObject = res.errors.message;
                        }
                        log.error(
                            "Could not save availability rules",
                            errorOutput
                        );
                        tempStatus = {
                            ...tempStatus,
                            saving: false,
                            saved: true,
                            savedSuccess: false
                        };
                    } else {
                        const callbackContent = {
                            notification: {
                                type: "availability_rule_saved"
                            },
                            availability_rule: res.availability_rule
                        };
                        status.ruleSaved(callbackContent);
                        tempStatus = {
                            ...tempStatus,
                            saving: false,
                            saved: true,
                            savedSuccess: true
                        };
                    }
                    setStatus(tempStatus);
                })
                .catch(error => {
                    log.error(
                        "There was a problem settting availability rules",
                        {
                            errorObject: error.message
                        }
                    );
                    tempStatus = {
                        ...tempStatus,
                        saving: false,
                        error: error
                    };
                    setStatus(tempStatus);
                    return error;
                });
        } else {
            log.warn("Invalid rulesRequest", {
                errorObject: rulesRequest
            });
        }
    };

    return (
        <Container
            height={"auto"}
            css={css`
                ${globals};
                max-width: 100%;
                margin-bottom: 40px;
                @media (max-width: 550px) {
                    overflow: hidden;
                }
            `}
            className={`${theme.prefix}`}
        >
            <LoggingContext.Provider value={log}>
                <I18nContext.Provider value={i18n}>
                    <ThemeContext.Provider value={[theme, setTheme]}>
                        <StatusContext.Provider value={[status, setStatus]}>
                            {status.error ? (
                                <Error
                                    message={i18n.t("global_error")}
                                    theme={theme}
                                />
                            ) : (
                                <React.Fragment>
                                    <CalendarContext.Provider
                                        value={[calendars, setCalendars]}
                                    >
                                        <Calendars loading={status.loading} />
                                    </CalendarContext.Provider>
                                    <ExtrasContext.Provider
                                        value={[extras, setExtras]}
                                    >
                                        <StaticSlotsContext.Provider
                                            value={staticSlots}
                                        >
                                            <SlotsContext.Provider
                                                value={slotsValue}
                                            >
                                                <Week />
                                            </SlotsContext.Provider>
                                        </StaticSlotsContext.Provider>
                                        <Footer generateRules={generateRules} />
                                    </ExtrasContext.Provider>
                                </React.Fragment>
                            )}
                        </StatusContext.Provider>
                    </ThemeContext.Provider>
                </I18nContext.Provider>
            </LoggingContext.Provider>
        </Container>
    );
};

export default AvailabilityRules;
