import React, { useState, useContext, useEffect } from "react";
import moment from "moment-timezone";
import { css, jsx } from "@emotion/core";

import { HoverContext, SelectionContext } from "./Week";
import { I18nContext, StatusContext, ThemeContext } from "./AvailabilityViewer";

import { buttonReset } from "../../styles/utils";
import { createExportableSelection } from "../../helpers/utils.AvailabilityViewer";

const Slot = ({ slot, day, topSlot, columnCount }) => {
    const i18n = useContext(I18nContext);
    const [hover, setHover] = useContext(HoverContext);
    const [selectedSlots, setSelectedSlots] = useContext(SelectionContext);
    const [status, setStatus] = useContext(StatusContext);
    const [theme, setTheme] = useContext(ThemeContext);

    const hoverButton = React.createRef();

    // Default slot info
    const [slotData, setSlotData] = useState({
        position: { y: 0, x: columnCount },
        topSlot: topSlot,
        slot: {
            start: slot.start,
            end: slot.end,
            participants: slot.participants
        }
    });

    const defaultTimeDisplayStart = i18n
        .f(moment(slot.start, "YYYY-MM-DDTTHH:mm:00Z").tz(status.tzid), "LT")
        .replace(" ", "");
    const defaultTimeDisplayEnd = i18n
        .f(moment(slot.end, "YYYY-MM-DDTTHH:mm:00Z").tz(status.tzid), "LT")
        .replace(" ", "");

    // Default time display
    const [timeDisplay, setTimeDisplay] = useState(
        `${defaultTimeDisplayStart} - ${defaultTimeDisplayEnd}`
    );

    const updateSlotData = () => {
        const hoverTopPosition = hoverButton.current.offsetTop;

        const targetSlot = slot.target
            ? day.slots.find(item => item.start === slot.target)
            : false;

        if (targetSlot) {
            // If the slot is "overlapped" by an available slot
            // we want to select the overlapping slot instead,
            // so let's find it and update our slot data.
            const targetYPosition =
                hoverTopPosition -
                theme.slotHeightCalc.height *
                    (theme.slotHeightCalc.multiple - slot.targetOffset);
            setSlotData({
                ...slotData,
                slot: {
                    available: targetSlot.available,
                    start: targetSlot.start,
                    end: targetSlot.end,
                    participants: targetSlot.participants
                },
                position: { y: targetYPosition, x: columnCount }
            });
        } else {
            setSlotData({
                ...slotData,
                slot: {
                    available: slot.available,
                    start: slot.start,
                    end: slot.end,
                    participants: slot.participants
                },
                position: { y: hoverTopPosition, x: columnCount }
            });
        }
    };

    useEffect(() => {
        updateSlotData();
    }, [slot]);

    useEffect(() => {
        updateSlotData();
    }, []);

    useEffect(() => {
        const timeStart = moment(
            slotData.slot.start,
            "YYYY-MM-DDTTHH:mm:00Z"
        ).tz(status.tzid);
        const timeDisplayStart = i18n.f(timeStart, "LT").replace(" ", "");

        const timeEnd = moment(slotData.slot.end, "YYYY-MM-DDTTHH:mm:00Z").tz(
            status.tzid
        );
        const timeDisplayEnd = i18n.f(timeEnd, "LT").replace(" ", "");

        setTimeDisplay(`${timeDisplayStart} - ${timeDisplayEnd}`);
    }, [slotData]);

    const handleHover = () => {
        const availibility =
            slot.visiblyAvailable && slot.target ? true : slot.available;

        setHover({
            times: timeDisplay,
            position: slotData.position,
            visible: true,
            topSlot,
            available: availibility,
            helicopterMode: false,
            hideTooltip: slot.blocked
        });
    };

    const overSelectionLimit =
        typeof status.maxSelection === "number"
            ? Object.keys(selectedSlots).length >= status.maxSelection
            : false;

    const handleSelect = () => {
        if (overSelectionLimit || slot.blocked) {
            return;
        }
        handleHover();

        if (
            slot.available ||
            (slot.visiblyAvailable && slot.target) ||
            status.slotSelection === "unrestricted"
        ) {
            const slotForSelection = {
                ...slotData,
                position: { y: hover.position.y, x: columnCount }
            };

            if (status.mode === "no_confirm") {
                setSelectedSlots({
                    [slotForSelection.slot.start]: slotForSelection
                });

                status.selectionConfirm({
                    notification: {
                        type: "slot_selected",
                        slot: slotForSelection.slot
                    }
                });
            } else {
                // The slot is available, and we're either in multi_select mode
                // or default mode (there *is* a confirmation step).

                // Add the newly selected slot to the list of selected slots.
                let newSlots = { ...selectedSlots };
                newSlots[slotForSelection.slot.start] = slotForSelection;
                setSelectedSlots(newSlots);

                // If we're in multi_select mode,
                if (status.multiSelect) {
                    const exportableSelection = createExportableSelection(
                        newSlots
                    );
                    const callbackContent = {
                        notification: {
                            type: "slot_added",
                            slot: slotForSelection.slot
                        },
                        slots: exportableSelection
                    };
                    status.selectionConfirm(callbackContent);
                }
            }
        }
    };

    const handleLiveHover = () => {
        // If we setState on MouseMove for slots, the fans on a 2019 🍏 MBP will start to
        // spin (sounding like a helicopter). But *sometimes* we need this "realtime" mouse
        // position (i.e. when clearing a selection and reseting hover).
        if (hover.helicopterMode) {
            handleHover();
        }
    };

    const handleHoverEnd = () => {
        setHover({
            ...hover,
            visible: false
        });
    };

    return (
        <button
            type="button"
            ref={hoverButton}
            css={css`
                ${buttonReset};
                height: 100%;
                width: 100%;
                display: block;
                cursor: ${slot.visiblyAvailable &&
                (overSelectionLimit || slot.blocked)
                    ? "not-allowed"
                    : "pointer"};
            `}
            onClick={handleSelect}
            onMouseOver={handleLiveHover}
            onMouseEnter={handleHover}
            onMouseOut={handleHoverEnd}
        >
            <span className="visuallyhidden">{timeDisplay}</span>
        </button>
    );
};
export default Slot;
