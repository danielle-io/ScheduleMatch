import moment from "moment-timezone";
import { createEmptySlotsForPeriod, roundPeriod } from "./slots";
import { objectToArray } from "./utils";

// Use the slot's "start" time-string as the
// key (for quicker/simpler look-up later)
export const addKeysToSlots = rawSlots => {
    if (rawSlots) {
        return rawSlots.reduce((acc, curr) => {
            acc[curr.start] = curr;
            return acc;
        }, {});
    } else {
        return {};
    }
};

export const sortKeys = keys =>
    keys.sort((a, b) => {
        if (moment.utc(a) < moment.utc(b)) {
            return -1;
        }
        if (moment.utc(a) > moment.utc(b)) {
            return 1;
        }
        return 0;
    });

export const getMinMaxDates = (queryPeriods = false) => {
    if (!queryPeriods) {
        return {
            min: moment.utc().format("YYYY-MM-DD"),
            max: moment
                .utc()
                .add(1, "days")
                .format("YYYY-MM-DD")
        };
    }

    const startDates = sortKeys(Object.keys(queryPeriods));

    return {
        min: moment
            .utc(queryPeriods[startDates[0]].start, "YYYY-MM-DDTHH:mm:00Z")
            .local()
            .format("YYYY-MM-DD"),
        max: moment
            .utc(
                queryPeriods[startDates[startDates.length - 1]].end,
                "YYYY-MM-DDTHH:mm:00Z"
            )
            .local()
            .format("YYYY-MM-DD")
    };
};

export const buildDayPeriod = (startTime, endTime, day, tzid) => {
    const localStart = `${day}T${startTime}`;
    const localEnd = `${day}T${endTime}`;
    const UTCStart = moment.tz(localStart, "YYYY-MM-DDTHH:mm", tzid).utc();
    const UTCEnd = moment.tz(localEnd, "YYYY-MM-DDTHH:mm", tzid).utc();

    const is24Hours = startTime === endTime;
    if (is24Hours) {
        UTCEnd.add(1, "days");
    }

    // An end-time of midnight will always be at the *end* of our
    // target day (a.k.a. the very start of the following day)
    const localMidnight = moment(`${day}T00:00`, "YYYY-MM-DDTHH:mm");
    if (UTCEnd.diff(localMidnight, "minutes") === 0) {
        UTCEnd.add(1, "days");
    }

    const start = UTCStart.format("YYYY-MM-DDTHH:mm[:00Z]");
    const end = UTCEnd.format("YYYY-MM-DDTHH:mm[:00Z]");

    return {
        start,
        end
    };
};

export const getDaysForWeek = startDate => {
    const start = startDate.clone();
    return [
        start.format("YYYY-MM-DD"),
        start.add(1, "days").format("YYYY-MM-DD"),
        start.add(1, "days").format("YYYY-MM-DD"),
        start.add(1, "days").format("YYYY-MM-DD"),
        start.add(1, "days").format("YYYY-MM-DD"),
        start.add(1, "days").format("YYYY-MM-DD"),
        start.add(1, "days").format("YYYY-MM-DD")
    ];
};

export const getDayOffset = day => {
    const offsets = {
        sunday: 0,
        monday: 1,
        tuesday: 2,
        wednesday: 3,
        thursday: 4,
        friday: 5,
        saturday: 6
    };
    return offsets[day];
};

export const getAllWeekDays = (startDate, endDate, startDay = "sunday") => {
    const start = moment.utc(startDate, "YYYY-MM-DD");
    const end = moment.utc(endDate, "YYYY-MM-DD");

    const dayOffset = getDayOffset(startDay);

    // NB: `startOf("week")` changes with locale setting - some times it uses
    // Monday as the first day of the week, and sometimes it uses Sunday. "week"
    // is therefore unpredictable).
    // "isoWeek" is consistent, but always starts on a Monday. To account for this
    // (because we want the week to start on Sunday) we'll add a day to our start-
    // date, calucate the closest preceding Monday, then subtract a week to give
    // the closest preceding *Sunday*.
    let startOfFirstWeek = start
        .add(1, "days")
        .startOf("isoWeek")
        .subtract(1, "days")
        .add(dayOffset, "days"); // account for custom startday

    let startOfLastWeek = end
        .add(1, "days")
        .startOf("isoWeek")
        .subtract(1, "days")
        .add(dayOffset, "days"); // account for custom startday

    const weekDiff = startOfLastWeek.diff(startOfFirstWeek, "weeks");

    const weekOne = getDaysForWeek(startOfFirstWeek);
    if (weekDiff <= 0) {
        return weekOne;
    }
    let extraWeeks = [];
    for (let i = 0; i < weekDiff; i++) {
        extraWeeks.push(...getDaysForWeek(startOfFirstWeek.add(7, "days")));
    }
    return [...weekOne, ...extraWeeks];
};

export const getWeeksInfo = weekdays => {
    return {
        set: true,
        current: 1,
        days: weekdays,
        total: Math.ceil(weekdays.length / 7)
    };
};

export const checkWeekdaysSlotAvailability = (
    weekdaysEmpties,
    availablePeriods,
    duration,
    interval,
    unrestricted
) => {
    const intervalsPerSlot = duration / interval;
    return weekdaysEmpties.map(day => {
        // Make sure the end time knows what day it applies to.
        const [lastSlotOfTheDay] = day.slots.slice(-1);
        const elementEndTime = moment.utc(
            lastSlotOfTheDay.end,
            "YYYY-MM-DDTHH:mm:00Z"
        );
        const slots = day.slots.map(slot => {
            // If a slot is `available` then it can be selected by a user.
            //
            // If a slot is `visiblyAvailable`, it cannot be directly selected, but
            // should be displayed as "available" (because it falls in the duration
            // overflow)
            //
            // If a slot is `blocked` it would normally be available, but is currently
            // unselectable becasue of an existing user selection (this is a dynamic
            // effect, and not set here).

            const slotStart = moment.utc(slot.start, "YYYY-MM-DDTHH:mm:00Z");
            const actualSlotEnd = slotStart.clone().add(duration, "minutes");

            // This is the slot object that we'll eventually return.
            let parsedSlot = {
                start: slot.start,
                end: actualSlotEnd.format("YYYY-MM-DDTHH:mm[:00Z]"),
                available: false,
                blocked: false,
                target: false,
                targetOffset: 0,
                visiblyAvailable: false,
                participants: []
            };

            // Does the slot overrun the end of the visible window?
            const endDiff = actualSlotEnd.diff(elementEndTime, "minutes");
            const overruns = endDiff > 0;

            if ((overruns && unrestricted) || (overruns && slot.available)) {
                // If the slot overruns, we need to caluclate the `target` and `targetOffset`

                // We know the end-time of the window already...
                const targetEndTime = moment(
                    elementEndTime,
                    "YYYY-MM-DDTHH:mm:00Z"
                );
                // ...so we can use that to calculate the start time of the "last selectable
                // slot" (which is what we mean by "target" slot).
                const targetStartTime = targetEndTime
                    .subtract(duration, "minutes")
                    .format("YYYY-MM-DDTHH:mm[:00Z]");

                const offsetInt = (duration - endDiff) / interval;

                parsedSlot.target = targetStartTime;
                parsedSlot.targetOffset = offsetInt;
            }

            const checkAvailabilityFor = parsedSlot.target
                ? parsedSlot.target
                : slot.start;
            const availableSlot =
                availablePeriods[checkAvailabilityFor] || false;
            if (availableSlot) {
                parsedSlot.available = true;
                parsedSlot.visiblyAvailable = true;
                parsedSlot.participants = availableSlot.participants;
            }
            // Check if there are any overlapping slots
            // Default to *not* visibly available.
            let isOverlapped = false;
            let overlappingSlotTimes = [];
            let overlappingSlotsCount = 0;
            if (intervalsPerSlot > 1) {
                for (let i = 1; i < intervalsPerSlot; i++) {
                    const potentialOverlappingStartTime = slotStart
                        .clone()
                        .subtract(i * interval, "minutes")
                        .format("YYYY-MM-DDTHH:mm[:00Z]");

                    const overlappingSlot =
                        availablePeriods[potentialOverlappingStartTime];

                    if (typeof overlappingSlot !== "undefined") {
                        overlappingSlotsCount++;
                        isOverlapped = true;
                        overlappingSlotTimes.push(
                            potentialOverlappingStartTime
                        );
                    } else {
                        if (overlappingSlotTimes.length > 0) {
                            overlappingSlotsCount++;
                        }
                    }
                }
            }
            if (isOverlapped && !parsedSlot.available) {
                // Only apply these values if the slot IS overlapped, but is
                // also NOT available in it's own right.
                parsedSlot.visiblyAvailable = true;
                if (!unrestricted) {
                    parsedSlot.target = overlappingSlotTimes[0];
                    parsedSlot.targetOffset = overlappingSlotsCount;
                }
            }

            return parsedSlot;
        });

        return {
            day: day.day,
            slots: slots
        };
    });
};

export const generateWeeklySlots = (
    { availablePeriods, limits, weeks, tzid, unrestricted },
    getEmpties = createEmptySlotsForPeriod,
    buildPeriod = buildDayPeriod
) => {
    const weekdaysEmpties = weeks.days.reduce((acc, day) => {
        const dayPeriod = buildPeriod(limits.start, limits.end, day, tzid);

        // Make sure the period starts on a round value (according to the duration)
        const roundedPeriod = roundPeriod(dayPeriod, limits.duration);

        acc.push({
            day: day,
            slots: getEmpties(roundedPeriod, limits.interval, tzid)
        });
        return acc;
    }, []);

    const allSlots = checkWeekdaysSlotAvailability(
        weekdaysEmpties,
        availablePeriods,
        limits.duration,
        limits.interval,
        unrestricted
    );

    return {
        weeks,
        slots: allSlots
    };
};

export const createExportableSelection = slots =>
    objectToArray(slots).map(item => item.value.slot);

export const checkBlockedSlots = ({
    slots,
    selected,
    duration = 60,
    interval = 60
}) => {
    const intervalsPerSlot = duration / interval;

    let precedingBlocks = [];
    let selectedBlocks = [];

    // We just need the `start` string values (used as the keys for the selected
    // slots object).
    const selectedKeys = Object.keys(selected);

    selectedKeys.map(key => {
        const blockSource = moment(key, "YYYY-MM-DDTHH:mm:00Z");
        for (let i = 1; i < intervalsPerSlot; i++) {
            // Get the `start` string for any slots directly covered
            // by the current selection.
            const selectedKey = blockSource
                .clone()
                .utc()
                .add(i * interval, "minutes")
                .format("YYYY-MM-DDTHH:mm[:00Z]");
            selectedBlocks.push(selectedKey);

            // Get the `start` string for any preceding slots that would
            // overlap the selected slot.
            const precedingOverlapKey = blockSource
                .clone()
                .utc()
                .subtract(i * interval, "minutes")
                .format("YYYY-MM-DDTHH:mm[:00Z]");
            precedingBlocks.push(precedingOverlapKey);
        }
    });

    const blockedSlots = slots.map(day => ({
        ...day,
        slots: day.slots.map(slot => {
            // Is this slot a `preceding` slot? (if so, it should be blocked).
            const precedingBlockStatus = precedingBlocks.includes(slot.start);

            // Is this slot at the end of an available period *and* with the overlap
            // region of a selected slot? (if so, it should be blocked).
            const followingBlockStatus =
                slot.target && selectedBlocks.includes(slot.target);

            const blockStatus =
                precedingBlockStatus || followingBlockStatus || false;
            return {
                ...slot,
                blocked: blockStatus
            };
        })
    }));
    return blockedSlots;
};

export const generateStaticWeeks = (queryPeriods, startDay) => {
    const periodsWithKeys = addKeysToSlots(queryPeriods);
    const minMax = getMinMaxDates(periodsWithKeys);
    const weekdays = getAllWeekDays(minMax.min, minMax.max, startDay);

    const weeks = getWeeksInfo(weekdays);
    return weeks;
};

export const divideDaysIntoWeeks = (days, currentWeek) =>
    [...days].slice((currentWeek - 1) * 7, currentWeek * 7);

// compare 2 periods (objects with start/end as moment instances).
// If they overlap, return that overlapping period as an object
// with start/end as "YYYY-MM-DDTHH:mm:00Z" strings.
// If they don't, return false.
export const periodOverlap = (testPeriod, wrapper) => {
    // If `testPeriod` ends before `wrapper` starts, then there's no overlap
    const endsBefore = testPeriod.end.diff(wrapper.start, "hours");
    // console.log(
    //     `${testPeriod.end.format(
    //         "(DD) HH:mm"
    //     )} [end] is ${endsBefore} hours after ${wrapper.start.format(
    //         "(DD) HH:mm"
    //     )} [start]`
    // );
    if (endsBefore <= 0) return false;

    // If `wrapper` starts after `testPeriod` ends, then there's no overlap
    const startsAfter = testPeriod.start.diff(wrapper.end, "hours");
    // console.log(
    //     `${testPeriod.start.format(
    //         "(DD) HH:mm"
    //     )} [start] is ${startsAfter} hours after ${wrapper.end.format(
    //         "(DD) HH:mm"
    //     )} [end]`
    // );
    if (startsAfter >= 0) return false;

    const startDiff = wrapper.start.diff(testPeriod.start, "minutes");
    const endDiff = testPeriod.end.diff(wrapper.end, "minutes");

    const newStart =
        startDiff < 0
            ? testPeriod.start.format("YYYY-MM-DDTHH:mm[:00Z]")
            : wrapper.start.format("YYYY-MM-DDTHH:mm[:00Z]");
    const newEnd =
        endDiff < 0
            ? testPeriod.end.format("YYYY-MM-DDTHH:mm[:00Z]")
            : wrapper.end.format("YYYY-MM-DDTHH:mm[:00Z]");
    const newPeriod = { start: newStart, end: newEnd };
    return newPeriod;
};

export const cropQuery = (query, extent) => {
    const days = divideDaysIntoWeeks(extent.days, extent.currentWeek);

    // These are the bounds within which our query should live:
    const bounds = days.map(day => {
        const localStart = extent.startTime;
        const localEnd = extent.endTime;

        const startTime = moment
            .tz(`${day}T${localStart}`, "YYYY-MM-DDTHH:mm", extent.tzid)
            .utc();

        const endTimeRaw = moment
            .tz(`${day}T${localEnd}`, "YYYY-MM-DDTHH:mm", extent.tzid)
            .utc();

        // If the endTime is an earlier hour than the startTime, that means
        // the period overflows a day boundary.
        const isEndBeforeStart = startTime.diff(endTimeRaw, "minutes") > 0;

        const endTime =
            isEndBeforeStart || extent.startTime === extent.endTime
                ? endTimeRaw.add(1, "days")
                : endTimeRaw;

        return {
            start: startTime,
            end: endTime
        };
    });

    const croppedPeriods = bounds.reduce((periodsAccumulator, day) => {
        const newPeriods = query.available_periods
            .map(period => {
                const periodStart = moment.utc(
                    period.start,
                    "YYYY-MM-DDTHH:mm:00Z"
                );
                const periodEnd = moment.utc(
                    period.end,
                    "YYYY-MM-DDTHH:mm:00Z"
                );
                const overlap = periodOverlap(
                    { start: periodStart, end: periodEnd },
                    day
                );

                return overlap;
            })
            .filter(period => period);

        return [...periodsAccumulator, ...newPeriods];
    }, []);

    return { ...query, available_periods: croppedPeriods };
};
