const moment = require("moment-timezone");
import { uniqueItems } from "./utils";

export const getDaysFromAvailablePeriods = (
    periods,
    locale,
    getUniques = uniqueItems
) => {
    const allDays = periods.map(period =>
        moment(period.start).format(`YYYY-MM-DD`)
    );

    const uniqueDays = getUniques(allDays);

    const days = uniqueDays.map(day => ({
        label: moment(day)
            .locale(locale)
            .format(`dddd Do MMMM`),
        value: moment(day).format(`YYYY-MM-DDT[T09:00:00Z]`)
    }));
    return days;
};

export const slotsFromPeriod = (period, duration, acc = []) => {
    const start = moment.utc(period.start, "YYYY-MM-DDTHH:mm:00Z");
    const end = moment.utc(period.end, "YYYY-MM-DDTHH:mm:00Z");
    const slotEnd = start.add(duration, "minutes");

    if (slotEnd.diff(end, "minutes") > 0) {
        return acc;
    }

    if (slotEnd.diff(end, "minutes") === 0) {
        return [
            ...acc,
            {
                start: period.start,
                end: period.end,
                participants: period.participants || []
            }
        ];
    }

    return slotsFromPeriod(
        {
            start: slotEnd.format(`YYYY-MM-DDTHH:mm[:00Z]`),
            end: period.end,
            participants: period.participants || []
        },
        duration,
        [
            ...acc,
            {
                start: period.start,
                end: slotEnd.format(`YYYY-MM-DDTHH:mm[:00Z]`),
                participants: period.participants || []
            }
        ]
    );
};

export const roundToNextHour = time =>
    time.minute() || time.second() || time.millisecond()
        ? time.add(1, "hour").startOf("hour")
        : time.startOf("hour");

export const roundToNextHalfHour = time => {
    const remainder = 30 - (time.minute() % 30);
    return time.minute() % 30 !== 0 || time.second() || time.millisecond()
        ? time.add(remainder, "minutes")
        : time;
};

export const roundToNextQuarterHour = time => {
    const remainder = 15 - (time.minute() % 15);
    return time.minute() % 15 !== 0 || time.second() || time.millisecond()
        ? time.add(remainder, "minutes")
        : time;
};

export const roundPeriod = (
    period,
    duration,
    hour = roundToNextHour,
    half = roundToNextHalfHour,
    quarter = roundToNextQuarterHour
) => {
    let start = moment.utc(period.start, "YYYY-MM-DDTHH:mm:00Z");

    if (duration > 30) {
        start = hour(start);
    } else if (duration > 15) {
        start = half(start);
    } else {
        start = quarter(start);
    }

    return { ...period, start: start.format(`YYYY-MM-DDTHH:mm[:00Z]`) };
};

export const parsePeriodsIntoSlots = (
    periods,
    duration = 30,
    getSlots = slotsFromPeriod
) =>
    periods.reduce((acc, period) => {
        const roundedPeriod = roundPeriod(period, duration);
        const newSlots = getSlots(roundedPeriod, duration);
        return [...acc, ...newSlots];
    }, []);

export const arangeSlotsByDay = (days, available_periods, locale) =>
    days.reduce(
        (acc, day) => ({
            ...acc,
            [day.value]: available_periods
                .filter(
                    period =>
                        moment(period.start)
                            .locale(locale)
                            .format(`YYYY-MM-DDT[T09:00:00Z]`) === day.value
                )
                .map(slot => ({
                    label: `${moment(slot.start)
                        .locale(locale)
                        .format("LT")
                        .replace(" ", "")} - ${moment(slot.end)
                        .locale(locale)
                        .format("LT")
                        .replace(" ", "")}`,
                    value: slot
                }))
        }),
        {}
    );

export const getWeekDays = startDate => {
    const start = moment.utc(startDate, "YYYY-MM-DDTHH:mm:00Z");
    const startOfWeek = start.startOf("isoWeek").subtract(1, "days");
    return [
        startOfWeek.format("YYYY-MM-DD"),
        startOfWeek.add(1, "days").format("YYYY-MM-DD"),
        startOfWeek.add(1, "days").format("YYYY-MM-DD"),
        startOfWeek.add(1, "days").format("YYYY-MM-DD"),
        startOfWeek.add(1, "days").format("YYYY-MM-DD"),
        startOfWeek.add(1, "days").format("YYYY-MM-DD"),
        startOfWeek.add(1, "days").format("YYYY-MM-DD")
    ];
};

export const createEmptySlotsForPeriod = (
    period,
    duration,
    tzid = false,
    acc = []
) => {
    // Work out the slot end (by adding the duration to the rounded period's start)
    const slotEnd = moment.utc(
        moment
            .utc(period.start, "YYYY-MM-DDTHH:mm:00Z")
            .add(duration, "minutes")
    );

    let duringDSTChangeover = false;
    // If we have a timezone to work with, check if we're inside a DST changeover.
    if (tzid) {
        // Get the local time.
        const localStart = moment(period.start, "YYYY-MM-DDTHH:mm:00Z")
            .clone()
            .tz(tzid);
        // Get the time an hour after the local start time.
        const localStartPlusHour = localStart
            .clone()
            .add(60, "minutes")
            .tz(tzid);

        // If the two *local* times are the same, then we're in the middle of a DST change.
        duringDSTChangeover =
            localStart.format("HH:mm") === localStartPlusHour.format("HH:mm");
    }

    // Check the difference between the slot end and the period end
    const endDiff = slotEnd.diff(
        moment.utc(period.end, "YYYY-MM-DDTHH:mm:00Z"),
        "minutes"
    );

    // if the slot-end is *after* the period-end, then we should do
    // nothing (and return the accumulated array of slots)
    if (endDiff > 0) {
        return acc;
    }

    // ...otherwise, (i.e. the slot-end is *before* the period-end) we
    // need to reset the period-start, and add a new slot to the
    // accumulating array of slots.
    const updatedPeriod = {
        start: slotEnd.format("YYYY-MM-DDTHH:mm[:00Z]"),
        end: period.end
    };

    const accumulatedSlots = [
        ...acc,
        {
            start: period.start,
            end: slotEnd.format("YYYY-MM-DDTHH:mm[:00Z]")
        }
    ];
    // ...then we recursively pass these into this very function to
    // begin the process all over again (repeating until a slot would
    // finish *after* the period has ended).
    if (!duringDSTChangeover) {
        return createEmptySlotsForPeriod(
            updatedPeriod,
            duration,
            tzid,
            accumulatedSlots
        );
    }

    // But if we're inside a DST-changeover, then we recur *without* adding to the slots.
    return createEmptySlotsForPeriod(updatedPeriod, duration, tzid, acc);
};

export const generateDummySlots = () => {
    const startOfCurrentWeek = moment
        .utc()
        .startOf("isoWeek")
        .subtract(1, "days");
    return [
        {
            day: startOfCurrentWeek.format("YYYY-MM-DD"),
            slots: []
        },
        {
            day: startOfCurrentWeek.add(1, "days").format("YYYY-MM-DD"),
            slots: []
        },
        {
            day: startOfCurrentWeek.add(1, "days").format("YYYY-MM-DD"),
            slots: []
        },
        {
            day: startOfCurrentWeek.add(1, "days").format("YYYY-MM-DD"),
            slots: []
        },
        {
            day: startOfCurrentWeek.add(1, "days").format("YYYY-MM-DD"),
            slots: []
        },
        {
            day: startOfCurrentWeek.add(1, "days").format("YYYY-MM-DD"),
            slots: []
        },
        {
            day: startOfCurrentWeek.add(1, "days").format("YYYY-MM-DD"),
            slots: []
        }
    ];
};

export const timeLabels = (limits, day, tzid) => {
    // If the endTime is an early hour than the startTime, that means
    // the period overflows a day boundary.

    const isEndBeforeStart =
        parseInt(limits.start, 10) >= parseInt(limits.end, 10);

    // If the end does overflow a day boundary, we need to increment the
    // end day to account for this.
    const endDay =
        isEndBeforeStart || limits.start === limits.end
            ? moment
                  .tz(day, "YYYY-MM-DD", tzid)
                  .add(1, "days")
                  .format("YYYY-MM-DD")
            : day;

    const timeLabelPeriod = {
        start: moment
            .tz(`${day}T${limits.start}`, "YYYY-MM-DDTHH:mm", tzid)
            .utc()
            .format(`YYYY-MM-DDTHH:mm[:00]`),
        end: moment
            .tz(`${endDay}T${limits.end}`, "YYYY-MM-DDTHH:mm", tzid)
            .utc()
            .format(`YYYY-MM-DDTHH:mm[:00]`)
    };
    const slots = createEmptySlotsForPeriod(timeLabelPeriod, limits.interval);
    const timeSlots = labelTimeSlots(slots);
    return timeSlots;
};

const labelTimeSlots = slots =>
    slots.map(slot => {
        const start = moment.utc(slot.start, "YYYY-MM-DDTHH:mm:00Z");
        const onTheHour = start.minutes() === 0;
        return { ...slot, hour: onTheHour };
    });

export const getSlotsForWeek = (slots = [], week = 1) => {
    if (slots.length < 7 * week) {
        return slots;
    }

    const start = (week - 1) * 7;
    const end = start + 7;

    return slots.slice(start, end);
};

export const calculateSlotHeight = limits => ({
    overflow: limits.duration / limits.interval - 1,
    multiple: limits.duration / limits.interval,
    height: limits.interval
});

export const parseInterval = option => {
    // Make sure we have an interval to start with...
    let interval = option ? option : 15;
    // Round it to the nearest 15 mins
    interval = Math.ceil(interval / 15) * 15;
    // If it's 45, bump it up to 60 [^1]
    interval = interval === 45 ? 60 : interval;
    // If it's over 60, round down [^1]
    interval = interval > 60 ? 60 : interval;
    // [:1] We currently only support the following intervals: 15 | 30 | 60
    return interval;
};

export const filterOverflowingSlots = (slots, overflow) =>
    slots.filter((slot, i) => {
        // Always return true (a.k.a. keep the slot) if it's unavailable.
        if (!slot.available) return true;

        // If any of the next [N = overflow] slots are
        // unavailable, then this post should be removed because it
        // would overflow the available period.
        for (let j = 1; j <= overflow; j++) {
            if (!slots[i + j] || !slots[i + j].available) {
                return false;
            }
        }

        // ...otherwise, keep the slot.
        return true;
    });

export const getMonthsDescription = slots => {
    const coverage = slots
        .map(slot => moment.utc(slot.day, "YYYY-MM-DD"))
        .reduce(
            (acc, curr) => {
                acc.months.push(curr.format("MMM"));
                acc.years.push(curr.format("YYYY"));
                return acc;
            },
            { months: [], years: [], combi: [] }
        );

    const months = uniqueItems(coverage.months);
    const years = uniqueItems(coverage.years);

    let result = "";

    // Does the period span 2 months and 2 years? (spanning 2 years but only 1 month is impossible)
    if (years.length > 1 && months.length > 1) {
        // N.B. this code relies on there being a max of 2 months in a single view
        result = `${months[0]} ${years[0]} - ${months[1]} ${years[1]}`;
    } else {
        result = `${months.join(" - ")} ${years[0]}`;
    }
    return result;
};

export const convertLocalToUTC = (timeString, tzid) => {
    const utcOffset = moment.tz(tzid).utcOffset();
    const invertedOffset =
        Math.sign(utcOffset) === -1 ? Math.abs(utcOffset) : 0 - utcOffset;
    const offset = invertedOffset / 60;

    const time = `${moment().format("YYYY-MM-DD")}T${timeString}:00Z`;
    const adjusted = moment(time).add(offset, "hours");
    const formatted = adjusted.utc().format("HH:mm");

    return formatted;
};

export const convertUTCToLocal = (timeString, tzid) => {
    const utcOffset = moment.tz(tzid).utcOffset();
    const invertedOffset =
        Math.sign(utcOffset) === -1 ? Math.abs(utcOffset) : 0 - utcOffset;
    const offset = invertedOffset / 60;

    const time = `${moment().format("YYYY-MM-DD")}T${timeString}:00Z`;
    const adjusted = moment(time).subtract(offset, "hours");
    const formatted = adjusted.utc().format("HH:mm");

    return formatted;
};
