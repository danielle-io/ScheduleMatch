import * as mocks from "./mocks";
import packageDetails from "../../../package";
import { errorMessages } from "./logging";

const handle422Responses = res => {
    if (res.errors) {
        throw {
            type: 422,
            message: errorMessages[422].message,
            body: res.errors,
            docsSlug: errorMessages[422].docsSlug
        };
    }
    return res;
};

const handleInvalidResponses = res => {
    // All 2** status are valid.
    // 422 is included because we want to handle those in
    // handle422Responses *after* res.body.json() has completed
    // (res.body is a ReadableStream until then)
    const okStatuses = [200, 201, 202, 422];

    if (okStatuses.includes(res.status)) {
        return res;
    }

    throw {
        type: res.status,
        message: errorMessages[res.status].message
    };
};

const handleInvalidRulesResponse = res => {
    if (res.status === 404) {
        // Rules treats a 404 as a valid response
        return res;
    }

    return handleInvalidResponses(res);
};

const catchAndRethrowErrors = error => {
    if (error.type) {
        throw error;
    }
    throw {
        type: 401,
        message: errorMessages[401].message,
        docsSlug: errorMessages[401].docsSlug
    };
};

export const parseCalendars = response =>
    response.calendars.map((cal, i) => ({
        name: cal.calendar_name,
        id: cal.calendar_id,
        color: i
    }));

export const getUserInfo = (token, api_domain, mock = false) => {
    if (mock) return mocks.userinfo;

    const url = new URL(`${api_domain}/v1/userinfo`);
    url.searchParams.append("et", token);

    return fetch(url, {
        method: "GET",
        headers: {
            "Cronofy-Element": `v${packageDetails.version}, agenda`
        }
    })
        .then(handleInvalidResponses)
        .then(res => res.json())
        .catch(catchAndRethrowErrors);
};

export const parseUserInfoCalendars = response => {
    const fullCalendars = response["cronofy.data"].profiles
        .map(profile => profile.profile_calendars)
        .reduce((acc, curr) => [...acc, ...curr], []);

    const parsedCalendars = fullCalendars.map((cal, i) => ({
        name: cal.calendar_name,
        id: cal.calendar_id,
        color: i
    }));
    return parsedCalendars;
};

export const parseRulesCalendars = response => {
    const calendars = response["cronofy.data"].profiles.map(profile => {
        return profile.profile_calendars
            .filter(cal => !cal.calendar_deleted)
            .map(cal => ({
                name: cal.calendar_name,
                id: cal.calendar_id,
                profile_name: profile.profile_name,
                provider_name: profile.provider_name
            }));
    });
    return calendars.reduce((acc, curr) => [...acc, ...curr], []);
};

export const parseEventsArgs = (args, token) => ({
    et: token,
    from: args.from,
    include_geo: true,
    include_managed: args.include_managed,
    include_userinfo: true,
    to: args.to,
    tzid: args.tzid
});

export const createEventsUrl = (api_domain, data) => {
    const url = new URL(`${api_domain}/v1/events`);
    Object.keys(data).forEach(key => url.searchParams.append(key, data[key]));
    return url;
};

export const getEvents = (
    token,
    api_domain,
    args,
    next = loadNextPage,
    mock = false
) => {
    if (mock) return mocks.eventsWithUserinfo;

    const data = parseEventsArgs(args, token);

    const url = createEventsUrl(api_domain, data);

    let events = [];

    return fetch(url, {
        method: "GET",
        headers: {
            "Cronofy-Element": `v${packageDetails.version}, agenda`
        }
    })
        .then(handleInvalidResponses)
        .then(res => res.json())
        .then(json => {
            const userinfo = json.userinfo;
            if (json.events.length > 0) {
                events.push(...json.events);
            }
            if (json.pages && json.pages.next_page) {
                return next(token, json.pages.next_page, events, userinfo);
            }
            return { events, userinfo };
        })
        .catch(catchAndRethrowErrors);
};

export const loadNextPage = (
    token,
    pageUrl,
    eventsArray,
    userinfo,
    callback = loadNextPage
) => {
    const newurl = new URL(pageUrl);
    newurl.searchParams.append("et", token);
    return fetch(newurl, {
        method: "GET",
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            "Cronofy-Element": `v${packageDetails.version}, agenda`
        }
    })
        .then(handleInvalidResponses)
        .then(res => res.json())
        .then(json => {
            if (json.events.length > 0) {
                eventsArray.push(...json.events);
            }
            if (json.pages && json.pages.next_page) {
                return callback(
                    token,
                    json.pages.next_page,
                    eventsArray,
                    userinfo
                );
            }
            return { events: eventsArray, userinfo };
        })
        .catch(catchAndRethrowErrors);
};

export const getAvailability = (
    token,
    api_domain,
    params = {},
    element = "availability",
    tzid = "Etc/UTC",
    mock = false
) => {
    if (
        (mock && params.response_format === "slots") ||
        (mock && typeof params.start_interval === "undefined")
    ) {
        return mocks.availabilitySlots;
    }
    if (mock && params.response_format === "overlapping_slots") {
        return mocks.availabilityOverlappingSlots(
            params.start_interval.minutes,
            params.required_duration.minutes,
            params.available_periods,
            tzid
        );
    }
    if (mock) return mocks.availability;

    return fetch(`${api_domain}/v1/availability?et=${token}`, {
        method: "POST",
        headers: {
            "Cronofy-Element": `v${packageDetails.version}, ${element}`,
            "Content-Type": "application/json; charset=utf-8"
        },
        body: JSON.stringify(params)
    })
        .then(handleInvalidResponses)
        .then(res => res.json())
        .then(handle422Responses)
        .catch(catchAndRethrowErrors);
};

export const getAvailabilityRules = (
    token,
    api_domain,
    availability_rule_id = false,
    element = "rules",
    mock = false
) => {
    if (mock) return mocks.availability_rules;

    const url = new URL(
        `${api_domain}/v1/availability_rules/${availability_rule_id}`
    );
    url.searchParams.append("et", token);

    return fetch(url, {
        method: "GET",
        headers: {
            "Cronofy-Element": `v${packageDetails.version}, ${element}`
        }
    })
        .then(handleInvalidRulesResponse)
        .then(res => {
            if (res.status === 404) {
                return { type: 404 };
            }
            return res.json();
        })
        .catch(catchAndRethrowErrors);
};

export const setAvailabilityRules = (
    token,
    api_domain,
    params = {},
    element = "rules",
    mock = false
) => {
    if (mock) return mocks.availability_rules;

    return fetch(`${api_domain}/v1/availability_rules?et=${token}`, {
        method: "POST",
        headers: {
            "Cronofy-Element": `v${packageDetails.version}, ${element}`,
            "Content-Type": "application/json; charset=utf-8"
        },
        body: JSON.stringify(params)
    })
        .then(handleInvalidResponses)
        .then(res => res.json())
        .catch(catchAndRethrowErrors);
};

export const revokeProfile = (
    token,
    api_domain,
    profile_id,
    element = "calendar-sync",
    mock = false
) => {
    if (mock) return mocks.revokeProfile;

    return fetch(`${api_domain}/v1/profiles/${profile_id}/revoke?et=${token}`, {
        method: "POST",
        headers: {
            "Cronofy-Element": `v${packageDetails.version}, ${element}`,
            "Content-Type": "application/json; charset=utf-8"
        }
    })
        .then(handleInvalidResponses)
        .catch(catchAndRethrowErrors);
};

export const getCalendars = (token, apiDomain, demo) =>
    getUserInfo(token, apiDomain, demo)
        .then(res => parseRulesCalendars(res))
        .catch(catchAndRethrowErrors);
