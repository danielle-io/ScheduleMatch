import moment from "moment-timezone";

import { createEmptySlotsForPeriod, roundPeriod } from "./slots";
import { buildSlotID, arrayOfDaySlots } from "./utils.AvailabilityRules";

export const getWeekDays = (startDay = "sunday") => {
    const dayOrders = {
        sunday: [0, 1, 2, 3, 4, 5, 6],
        monday: [1, 2, 3, 4, 5, 6, 0],
        tuesday: [2, 3, 4, 5, 6, 0, 1],
        wednesday: [3, 4, 5, 6, 0, 1, 2],
        thursday: [4, 5, 6, 0, 1, 2, 3],
        friday: [5, 6, 0, 1, 2, 3, 4],
        saturday: [6, 0, 1, 2, 3, 4, 5]
    };
    const dayNames = Object.keys(dayOrders);
    return dayOrders[startDay].map(day => dayNames[day]);
};

export const generateEmptyRulesSlots = (
    limits,
    startDay = "sunday",
    getEmpties = createEmptySlotsForPeriod
) => {
    const days = getWeekDays(startDay);
    const slots = {};

    // We're just interested in the times. But we'll fill-in the rest of the
    // date (using today) so we can use the getEmpties function (which expects
    // to be given full dates).
    const today = moment().format("YYYY-MM-DD");
    const period = {
        start: moment(`${today}T${limits.start}`, "YYYY-MM-DDTHH:mm").format(
            `YYYY-MM-DDTHH:mm[:00]`
        ),
        end: moment(`${today}T${limits.end}`, "YYYY-MM-DDTHH:mm").format(
            `YYYY-MM-DDTHH:mm[:00]`
        )
    };

    // Make sure the period starts on a round value (according to the duration)
    const roundedPeriod = roundPeriod(period, limits.duration);

    const daySlots = getEmpties(roundedPeriod, limits.duration);
    const slotTimes = daySlots.map(slot => ({
        start: moment(slot.start, "YYYY-MM-DDTHH:mm").format(`HH:mm`),
        end: moment(slot.end, "YYYY-MM-DDTHH:mm").format(`HH:mm`)
    }));

    days.forEach((day, day_index) => {
        slotTimes.forEach((slot, slot_index) => {
            const slotID = buildSlotID(day_index, slot_index);
            slots[slotID] = {
                day: day,
                start: slot.start,
                end: slot.end,
                available: false,
                id: slotID,
                dragged: false
            };
        });
    });
    return slots;
};

export const isSlotWithinPeriod = (slot, periods) => {
    const availability = periods.map(period => {
        // If the day doesn't match, let's stop checking...
        if (period.day !== slot.day) {
            return false;
        }

        // Account for slots that end at midnight
        const twentyfourHourSlotEnd = slot.end === "00:00" ? "24:00" : slot.end;

        // If the end_time is before the slot's start, let's stop checking...
        const slotStart = moment(slot.start, "HH:mm");
        const periodEnd = moment(period.end_time, "HH:mm");
        const diff_1 = periodEnd.diff(slotStart, "minutes");
        if (diff_1 <= 0) {
            // console.log(`${period.end_time} is before ${slot.start}`);
            return false;
        }
        // If the start_time is after the slot's end, let's stop checking...
        const slotEnd = moment(twentyfourHourSlotEnd, "HH:mm");
        const periodStart = moment(period.start_time, "HH:mm");
        const diff_2 = slotEnd.diff(periodStart, "minutes");
        if (diff_2 <= 0) {
            // console.log(
            //     `${period.start_time} is after (or equal to) ${twentyfourHourSlotEnd}`
            // );
            return false;
        }
        // If the start_time is after the slot's start, let's stop checking... (because
        // we only want slots that are *completely* within the available period)
        const diff_3 = slotStart.diff(periodStart, "minutes");
        if (diff_3 < 0) {
            // console.log(`${period.start_time} is after ${slot.start}`);
            return false;
        }
        // If we've got this far, then the slot must be within the period 👍👍👍
        return true;
    });
    // Are any of the periods "available"?
    const available = availability.some(item => item);
    return available;
};

export const checkSlotAvailability = (periods, emptySlots) => {
    const checkedSlots = {};
    Object.keys(emptySlots).map(key => {
        const slot = emptySlots[key];
        checkedSlots[key] = {
            ...slot,
            available: isSlotWithinPeriod(slot, periods)
        };
    });
    return checkedSlots;
};

export const findSlotsByDay = (slots, day) =>
    slots.filter(slot => slot.day === day);

export const parseSlotsIntoDays = (slots, slotsPerDay) => {
    const dayNumbers = [0, 1, 2, 3, 4, 5, 6];
    const dayNames = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
    ];

    return dayNumbers.map(day => {
        const daySlots = {};
        for (let i = 0; i < slotsPerDay; i++) {
            const slotID = buildSlotID(day, i);
            const slot = slots[slotID];
            daySlots[slotID] = slot;
        }
        return { day: dayNames[day], slots };
    });
};

export const buildNewRules = slots => {
    const rules = [];
    const mappableSlots = Object.keys(slots).map(key => slots[key]);
    const onlyAvailableSlots = mappableSlots.filter(slot => slot.available);
    for (let i = 0; i < onlyAvailableSlots.length; i++) {
        const slot = onlyAvailableSlots[i];
        if (slot) {
            const day = slot.day;
            const start_time = slot.start;

            const ending = getEndTime(onlyAvailableSlots, i, slot.end);

            const twentyfourHourEnd =
                ending.end === "00:00" ? "24:00" : ending.end;

            const rule = {
                day,
                start_time,
                end_time: twentyfourHourEnd
            };
            rules.push(rule);
            for (let j = i; j <= ending.index; j++) {
                onlyAvailableSlots[j] = false;
            }
        }
    }
    return rules;
};

export const getEndTime = (slots, index, end) => {
    const currentSlot = slots[index];
    const nextSlot = slots[index + 1];
    const nextSlotOverlaps =
        nextSlot &&
        nextSlot.day === currentSlot.day &&
        nextSlot.start === currentSlot.end;
    if (nextSlotOverlaps) {
        return getEndTime(slots, index + 1, nextSlot.end);
    }
    return { end, index };
};

export const connectSlots = (start_id, current_id) => {
    // console.log("start_id, current_id", start_id, current_id);
    const start_indexes = start_id.split("_");
    const end___indexes = current_id.split("_");

    const indexes = [
        {
            x: parseInt(start_indexes[0], 10),
            y: parseInt(start_indexes[1], 10)
        },
        {
            x: parseInt(end___indexes[0], 10),
            y: parseInt(end___indexes[1], 10)
        }
    ];

    indexes.sort((a, b) => {
        if (a.y < b.y) {
            return -1;
        }
        if (a.y > b.y) {
            return 1;
        }
        return 0;
    });

    let dragged = [];

    for (let i = indexes[0].y; i <= indexes[1].y; i++) {
        dragged.push(buildSlotID(start_indexes[0], i));
    }

    return dragged;
};

export const buildStaticSlots = (slots, slotsPerDay) =>
    arrayOfDaySlots(
        parseSlotsIntoDays(slots, slotsPerDay)[0].slots,
        0,
        slotsPerDay
    );
