import { turnSlugIntoString } from "./utils";
import { translations } from "./translations";

export const getNavigatorLanguage = (nav = navigator) =>
    nav.languages && nav.languages.length
        ? nav.languages[0]
        : nav.userLanguage || nav.language || nav.browserLanguage || "en";

export const i18n = (
    context = "core",
    phrase,
    locale = getNavigatorLanguage(),
    allPhrases = translations
) => {
    // Handle "keys" mode
    if (locale === "keys") {
        return `${context}.${phrase}`;
    }

    // Parse the locale (if it's one we want to normalize)
    locale = locale === "en-US" ? "en" : locale;

    // 1. Pre-check fallbacks
    // ...we don't have the provided context or locale.

    if (typeof allPhrases[locale] === "undefined" && locale !== "keys") {
        // Fallback to base locale
        locale = "en";
    }

    if (typeof allPhrases[locale][context] === "undefined") {
        // Fallback to base context
        context = "core";
    }

    if (typeof allPhrases[locale][context][phrase] !== "undefined") {
        // Happy path:
        return allPhrases[locale][context][phrase];

        // 2. Post-check fallbacks
        // ...we have the provided context and locale, but the phrase can't be found.
    } else if (typeof allPhrases[locale]["core"][phrase] !== "undefined") {
        // Check the phrase with our base context:
        return allPhrases[locale]["core"][phrase];
    } else if (typeof allPhrases["en"]["core"][phrase] !== "undefined") {
        // Check the phrase with our base context and default locale:
        return allPhrases["en"]["core"][phrase];
    } else {
        // Nothing has worked, so let's return a string to
        // highlight the error but not break the app.
        console.warn(
            `Missing translation. slug: ${phrase}, context: ${context}`
        );
        return turnSlugIntoString(phrase);
    }
};

export const tzi18n = (
    tzid,
    locale = getNavigatorLanguage(),
    exceptions = translations
) => {
    // console.log("timezones", timezones);
    // Parse the locale (if it's one we want to normalize)
    locale = locale === "en-US" ? "en" : locale;

    // 1. Pre-check fallbacks
    // ...we don't have the provided locale.

    if (typeof exceptions[locale] === "undefined") {
        // Fallback to base locale
        locale = "en";
    }

    if (typeof exceptions[locale].time_zones === "undefined") {
        // Fallback to base locale
        locale = "en";
    }

    if (typeof exceptions[locale].time_zones[tzid] !== "undefined") {
        // There is an exception:
        return exceptions[locale].time_zones[tzid];
    }

    // If we get here, the tzid string doesn't match any exceptions,
    // so we'll infer the visually-acceptable version.
    return tzid
        .split("/")
        .pop()
        .replace("_", " ");
};

export const i18nConstructor = (
    context = "core",
    locale = getNavigatorLanguage(),
    allPhrases = translations
) => ({
    t: slug => i18n(context, slug, locale, allPhrases),
    f: (momentObject, formatString) =>
        momentObject.locale(locale).format(formatString)
});
