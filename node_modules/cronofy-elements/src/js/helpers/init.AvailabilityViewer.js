import moment from "moment-timezone";
import {
    parseToken,
    parseTarget,
    parseQuery,
    parseConnectionDomains,
    parseTranslations
} from "./init";
import { logConstructor } from "./logging";

export const parseAvailabilityViewerOptions = (options = {}) => {
    let config = typeof options.config === "undefined" ? {} : options.config;
    const logs = typeof config.logs === "undefined" ? "warn" : config.logs;
    const log = logConstructor(logs, "Availability Viewer");

    options.error = false;
    const demoMode = typeof options.demo === "undefined" ? false : options.demo;
    if (demoMode) {
        log.warn("You are running in demo mode. No API requests will be made");
    }

    const token = parseToken(options, "availability-viewer", log);
    if (!token && !demoMode) {
        log.error(
            "You need to include an `element_token`. If you're just testing (and don't want to use real API data) you can set the `demo` option to `true` to bypass the API connection and view dummy content."
        );
        return false;
    }

    const target = parseTarget(options, "availability-viewer", log);
    const query = parseQuery(options, "availability-viewer", log);
    if (!query) return false;

    if (typeof options.extras !== "undefined") {
        log.warn(
            "The `extras` option has been deprecated in v1.0.0. Please use `config` option instead.",
            { docsSlug: "availability-viewer/#config" }
        );
        config = options.extras;
    }
    if (typeof options.config !== "undefined") {
        config = { ...config, ...options.config };
    }

    if (typeof options.tzid === "undefined") {
        const sniffedTimezone = moment.tz.guess();
        options.tzid = sniffedTimezone;
        options.customtzid = false;
    } else {
        options.customtzid = true;
    }

    const mode =
        typeof config.mode === "undefined" || config.mode === "default"
            ? "confirm"
            : config.mode;

    const slot_selection =
        typeof config.slot_selection === "undefined" ||
        config.slot_selection === "default"
            ? "available"
            : config.slot_selection;

    const boundsControl =
        typeof config.bounds_control === "undefined" ||
        config.bounds_control === "default"
            ? false
            : true;

    const startDay =
        typeof config.week_start_day === "undefined" ||
        config.week_start_day === "default"
            ? "sunday"
            : config.week_start_day;

    const validStartDays = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
    ];
    const validStartDay = validStartDays.includes(startDay);

    if (!validStartDay) {
        log.error(
            `Please provide a valid \`config.week_start_day\`. \`${startDay}\` is not a supported value.`,
            {
                docsSlug: "availability-viewer/#config.week_start_day"
            }
        );
        return false;
    }

    config = { ...config, startDay, mode, boundsControl, slot_selection, logs };

    const domains = parseConnectionDomains(
        options.data_center,
        options.api_domain,
        options.app_domain
    );

    const translations = parseTranslations(
        options.translations,
        "availability_rules"
    );

    config.start_time = config.start_time || "09:00";
    config.end_time = config.end_time || "17:30";

    const validStart = moment(config.start_time, "HH:mm").isValid();
    const validEnd = moment(config.end_time, "HH:mm").isValid();

    if (!validStart || !validEnd) {
        log.error(
            "Please provide a valid `config.start_time` and `config.end_time`.",
            { docsSlug: "availability-viewer/#config.start_time" }
        );
        return false;
    }

    delete options.availability_query;
    delete options.element_token;
    delete options.target_id;
    delete config.bounds_control;
    delete config.week_start_day;
    delete config.translations;

    return {
        ...options,
        target,
        token,
        domains,
        config,
        query,
        translations
    };
};
