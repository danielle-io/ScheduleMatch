import moment from "moment-timezone";
import merge from "deepmerge";
import { uniqueItems } from "./utils";

export const isAllDayEvent = (start, end) =>
    checkISO8601(start) && checkISO8601(end);

export const checkISO8601 = string => /^\d{4}-\d{2}-\d{2}$/.test(string);

export const dayNumbersString = (startObj, endObj, currentDay) => {
    const days = dayNumbers(startObj, endObj, currentDay);
    const multi = days.days > 1 ? ` - ${days.day}/${days.days}` : ``;
    return multi;
};

export const dayNumbers = (startObj, endObj, currentDay) => {
    const days = endObj.diff(startObj, "days");
    const dayDiff = endObj.diff(moment(currentDay), "days");
    const day = days - dayDiff + 1;
    return { days, day };
};

export const getMultiDayStatus = (start, end, current) => {
    const allDay = isAllDayEvent(start, end);
    if (!allDay) return 0;
    const days = dayNumbers(moment(start), moment(end), current);
    if (days.days <= 1) return 0;
    if (days.day === 1) return 1;
    if (days.day === days.days) return 2;
    return 3;
};

export const checkDirection = (target, current) => {
    const dayDiff = target.diff(current, "days");
    const result = dayDiff > 0 ? "forwards" : "backwards";
    return result;
};

// Add the uid for an event to every day that the event covers
export const eventDates = event => {
    const first = moment(event.start);
    const last = moment(event.end);
    const dayCount = last.diff(first, "days");
    const dates = {};
    dates[first.format(`YYYY-MM-DD`)] = {
        [event.event_uid]: true
    };
    for (let i = 1; i < dayCount; i++) {
        let current = first;
        current.add(1, "days");
        dates[current.format(`YYYY-MM-DD`)] = {
            [event.event_uid]: true
        };
    }
    return dates;
};

// Add a date object for each date in the selected range (targetDate +- offset)
export const getDayRange = (targetDate, offset, existingDays = {}) => {
    const days = existingDays;
    for (let i = 0 - offset; i <= offset; i++) {
        const day = moment(targetDate)
            .add(i, "days")
            .format(`YYYY-MM-DD`);
        days[day] = {};
    }
    return days;
};

export const setEventDayIDs = (
    events,
    daysObject,
    eventDatesFunc = eventDates
) => {
    let output = daysObject;
    events.map(event => {
        const days = { ...output };
        const thisEventDays = eventDatesFunc(event);
        output = merge(days, thisEventDays);
    });
    return output;
};

export const parseEventsByID = (events, existingEvents = {}) => {
    const eventsOutput = existingEvents;
    // for each event, add the event to the output, using its uid as a key
    events.map(event => {
        eventsOutput[event.event_uid] = event;
    });
    return eventsOutput;
};

// calculateLimit returns:
//  0 = not at limit
// -1 = at backward limit
//  1 = at forward limit
export const calculateLimit = (current, anchor) => {
    const today = moment(anchor);
    const target = moment(current);
    const limits = [-14, 90]; // 2 weeks behind | 3 months ahead
    const diff = target.diff(today, "days");
    let limit = 0;
    if (diff > limits[1]) limit = 1;
    if (diff < limits[0]) limit = -1;
    return limit;
};

export const sortEventsByType = events => {
    const allDayEvents = events.filter(event =>
        isAllDayEvent(event.start, event.end)
    );
    const timedEvents = events
        .filter(event => !isAllDayEvent(event.start, event.end))
        .sort((a, b) => {
            if (moment(a.start) < moment(b.start)) {
                return -1;
            }
            if (moment(a.start) > moment(b.start)) {
                return 1;
            }
            return 0;
        });
    return { allDay: allDayEvents, timed: timedEvents };
};

export const getEventByID = (id, events) =>
    events.find(event => event.event_uid === id);

export const getCalColor = (id, cals) =>
    cals.filter(cal => cal.id == id).reduce((acc, curr) => curr.color, 0);

export const parseDirection = directionInput => {
    let direction;
    switch (directionInput) {
        case "backwards":
        case "backward":
        case "back":
            direction = "backwards";
            break;
        case "upwards":
        case "upward":
        case "up":
            direction = "upwards";
            break;
        case "downwards":
        case "downward":
        case "down":
            direction = "downwards";
            break;
        default:
            direction = "forwards";
            break;
    }
    return direction;
};

export const getCalendarsFromEvents = events => {
    const allCalendarIDs = events.map(event => event.calendar_id);
    const uniqueIDs = uniqueItems(allCalendarIDs);
    const calendars = uniqueIDs.map((ID, index) => ({ id: ID, color: index }));
    return calendars;
};

// Check crucial event properties to make sure they exist (and apply fallback if needed)
export const parseEvents = events =>
    events.map(event => ({
        ...event,
        summary: event.summary || "â€“"
    }));
