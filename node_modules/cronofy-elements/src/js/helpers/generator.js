// import React from "react";
import ReactDOM from "react-dom";

import Error from "../components/generic/Error";
import { logConstructor } from "./logging";

const renderError = targetId => {
    const target = document.getElementById(targetId);
    if (!target) return false;

    ReactDOM.render(
        <div
            className="error__wrapper"
            style={{ position: "relative", minHeight: "200px" }}
        >
            <Error
                message={
                    "There was a problem with the UI Elements configuration settings. See the developer console for more detail."
                }
                theme={{ colors: { black: "#4D4D4D" } }}
            />
        </div>,
        target
    );
};

/**
 * This is a wrapper to handle re-rendering logic when `options` are
 * changed.
 */
export const generateElementAPI = (
    Renderer,
    options,
    optionsFormatter,
    elementName
) => {
    let config = typeof options.config === "undefined" ? {} : options.config;
    const logs = typeof config.logs === "undefined" ? "warn" : config.logs;
    const log = logConstructor(logs, elementName);

    const originalOptions = { ...options };
    const renderElement = (key, options, target) => {
        ReactDOM.render(Renderer(key, options), target);
    };

    // We need to change the key every time we reload the Element (to trigger)
    let key = 1;

    const parsedOptions = optionsFormatter(options);
    if (!parsedOptions) {
        renderError(options.target_id);
        return false;
    }
    const target = document.getElementById(parsedOptions.target);

    if (!target) {
        log.error(`${parsedOptions.target} is not a valid DOM element`);
        return false;
    }

    renderElement(key, parsedOptions, target);

    const reload = newRawOptions => {
        // Increment the key - this will ensure the React
        // component re-renders when the `options` change.
        key++;
        // Check our options for error/omissions
        const newOptions = optionsFormatter(newRawOptions);
        // Start the re-render
        renderElement(key, newOptions, target);
    };

    return {
        update: newOptions => reload({ ...originalOptions, ...newOptions })
    };
};
