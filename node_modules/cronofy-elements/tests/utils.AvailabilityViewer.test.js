import * as utils from "../src/js/helpers/utils.AvailabilityViewer";
// import moment from "moment";

describe("Utilities: AvailabilityViewer", () => {
    // addKeysToSlots
    it("turns an array of slots into an object, using the start date as a key", () => {
        const input = [
            {
                end: "2019-04-06T09:00:00Z",
                participants: [{ sub: "EXAMPLE_SUB" }],
                start: "2019-04-06T08:00:00Z"
            },
            {
                end: "2019-05-06T09:00:00Z",
                participants: [{ sub: "EXAMPLE_SUB" }],
                start: "2019-05-06T08:00:00Z"
            },
            {
                end: "2019-05-07T09:00:00Z",
                start: "2019-05-07T08:00:00Z"
            }
        ];
        const expectedOutput = {
            "2019-04-06T08:00:00Z": {
                end: "2019-04-06T09:00:00Z",
                participants: [{ sub: "EXAMPLE_SUB" }],
                start: "2019-04-06T08:00:00Z"
            },
            "2019-05-06T08:00:00Z": {
                end: "2019-05-06T09:00:00Z",
                participants: [{ sub: "EXAMPLE_SUB" }],
                start: "2019-05-06T08:00:00Z"
            },
            "2019-05-07T08:00:00Z": {
                end: "2019-05-07T09:00:00Z",
                start: "2019-05-07T08:00:00Z"
            }
        };
        expect(utils.addKeysToSlots(input)).toEqual(expectedOutput);
    });

    // sortKeys
    it("sorts array of date-keys into ascending order", () => {
        const input = [
            "2019-05-06T08:00:00Z",
            "2019-04-06T08:00:00Z",
            "2019-05-07T08:00:00Z",
            "2018-05-07T08:00:00Z",
            "2018-05-07T10:00:00Z",
            "2018-05-07T09:00:00Z",
            "2020-05-07T08:00:00Z"
        ];
        const expectedOutput = [
            "2018-05-07T08:00:00Z",
            "2018-05-07T09:00:00Z",
            "2018-05-07T10:00:00Z",
            "2019-04-06T08:00:00Z",
            "2019-05-06T08:00:00Z",
            "2019-05-07T08:00:00Z",
            "2020-05-07T08:00:00Z"
        ];
        expect(utils.sortKeys(input)).toEqual(expectedOutput);
    });

    // getMinMaxDates
    it("gets the first and last start-dates for a given set of slots", () => {
        const input = {
            "2019-04-06T08:00:00Z": {
                end: "2019-04-06T09:00:00Z",
                participants: [{ sub: "EXAMPLE_SUB" }],
                start: "2019-04-06T08:00:00Z"
            },
            "2019-05-06T08:00:00Z": {
                end: "2019-05-06T09:00:00Z",
                participants: [{ sub: "EXAMPLE_SUB" }],
                start: "2019-05-06T08:00:00Z"
            },
            "2019-05-07T08:00:00Z": {
                end: "2019-05-07T09:00:00Z",
                start: "2019-05-07T08:00:00Z"
            }
        };
        const expectedOutput = {
            max: "2019-05-07",
            min: "2019-04-06"
        };
        expect(utils.getMinMaxDates(input)).toEqual(expectedOutput);
    });
    it("provides sensible fallbacks for min/max when there's no data", () => {
        const expectedOutput = {
            min: moment.utc().format("YYYY-MM-DD"),
            max: moment
                .utc()
                .add(1, "days")
                .format("YYYY-MM-DD")
        };
        expect(utils.getMinMaxDates()).toEqual(expectedOutput);
    });

    // getAllWeekDays
    it("gets all the week days for a given period", () => {
        const input = [
            "2019-04-02", // Tue
            "2019-04-04" // Thu
        ];
        const out = [
            "2019-03-31", // Sun
            "2019-04-01", // Mon
            "2019-04-02", // Tue
            "2019-04-03", // Wed
            "2019-04-04", // Thu
            "2019-04-05", // Fri
            "2019-04-06" // Sat
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period with a specific start day", () => {
        const input = [
            "2019-04-02", // Tue
            "2019-04-04", // Thu
            "wednesday"
        ];
        const out = [
            "2019-04-03", // Wed
            "2019-04-04", // Thu
            "2019-04-05", // Fri
            "2019-04-06", // Sat
            "2019-04-07", // Sun
            "2019-04-08", // Mon
            "2019-04-09" // Tue
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that spans two weeks", () => {
        const input = [
            "2019-04-02", // Tue 1
            "2019-04-10" // Wed 2
        ];
        const out = [
            "2019-03-31", // Sun
            "2019-04-01", // Mon
            "2019-04-02", // Tue
            "2019-04-03", // Wed
            "2019-04-04", // Thu
            "2019-04-05", // Fri
            "2019-04-06", // Sat
            "2019-04-07", // Sun 2
            "2019-04-08", // Mon 2
            "2019-04-09", // Tue 2
            "2019-04-10", // Wed 2
            "2019-04-11", // Thu 2
            "2019-04-12", // Fri 2
            "2019-04-13" // Sat 2
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that spans two weeks with a specific start day", () => {
        const input = [
            "2019-04-02", // Tue 1
            "2019-04-10", // Wed 2
            "wednesday"
        ];
        const out = [
            "2019-04-03", // Wed
            "2019-04-04", // Thu
            "2019-04-05", // Fri
            "2019-04-06", // Sat
            "2019-04-07", // Sun
            "2019-04-08", // Mon
            "2019-04-09", // Tue
            "2019-04-10", // Wed 2
            "2019-04-11", // Thu 2
            "2019-04-12", // Fri 2
            "2019-04-13", // Sat 2
            "2019-04-14", // Sun 2
            "2019-04-15", // Mon 2
            "2019-04-16" // Tue 2
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that spans three weeks", () => {
        const input = [
            "2019-04-02", // Tue 1
            "2019-04-16" // Tue 3
        ];
        const out = [
            "2019-03-31", // Sun
            "2019-04-01", // Mon
            "2019-04-02", // Tue
            "2019-04-03", // Wed
            "2019-04-04", // Thu
            "2019-04-05", // Fri
            "2019-04-06", // Sat
            "2019-04-07", // Sun 2
            "2019-04-08", // Mon 2
            "2019-04-09", // Tue 2
            "2019-04-10", // Wed 2
            "2019-04-11", // Thu 2
            "2019-04-12", // Fri 2
            "2019-04-13", // Sat 2
            "2019-04-14", // Sun 3
            "2019-04-15", // Mon 3
            "2019-04-16", // Tue 3
            "2019-04-17", // Wed 3
            "2019-04-18", // Thu 3
            "2019-04-19", // Fri 3
            "2019-04-20" // Sat 3
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that spans three weeks with a specific start day", () => {
        const input = [
            "2019-04-02", // Tue 1
            "2019-04-16", // Tue 3
            "wednesday"
        ];
        const out = [
            "2019-04-03", // Wed
            "2019-04-04", // Thu
            "2019-04-05", // Fri
            "2019-04-06", // Sat
            "2019-04-07", // Sun
            "2019-04-08", // Mon
            "2019-04-09", // Tue
            "2019-04-10", // Wed 2
            "2019-04-11", // Thu 2
            "2019-04-12", // Fri 2
            "2019-04-13", // Sat 2
            "2019-04-14", // Sun 2
            "2019-04-15", // Mon 2
            "2019-04-16", // Tue 2
            "2019-04-17", // Wed 3
            "2019-04-18", // Thu 3
            "2019-04-19", // Fri 3
            "2019-04-20", // Sat 3
            "2019-04-21", // Sun 3
            "2019-04-22", // Mon 3
            "2019-04-23" // Tue 3
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that starts on a Sunday", () => {
        const input = [
            "2020-06-07", // Sun
            "2020-06-10" // Wed
        ];
        const out = [
            "2020-06-07", // Sun
            "2020-06-08", // Mon
            "2020-06-09", // Tue
            "2020-06-10", // Wed
            "2020-06-11", // Thu
            "2020-06-12", // Fri
            "2020-06-13" // Sat
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that starts on a Saturday", () => {
        const input = [
            "2020-06-06", // Sat
            "2020-06-10" // Wed
        ];
        const out = [
            "2020-05-31", // Sun
            "2020-06-01", // Mon
            "2020-06-02", // Tue
            "2020-06-03", // Wed
            "2020-06-04", // Thu
            "2020-06-05", // Fri
            "2020-06-06", // Sat
            "2020-06-07", // Sun
            "2020-06-08", // Mon
            "2020-06-09", // Tue
            "2020-06-10", // Wed
            "2020-06-11", // Thu
            "2020-06-12", // Fri
            "2020-06-13" // Sat
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });
    it("gets all the week days for a given period that starts on the same day as provided as a week_start_day", () => {
        const input = [
            "2020-06-09", // Tue
            "2020-06-12", // Fri
            "tuesday"
        ];
        const out = [
            "2020-06-09", // Tue
            "2020-06-10", // Wed
            "2020-06-11", // Thu
            "2020-06-12", // Fri
            "2020-06-13", // Sat
            "2020-06-14", // Sun
            "2020-06-15" // Mon
        ];
        expect(utils.getAllWeekDays(...input)).toEqual(out);
    });

    // cropQuery
    const cropExtent = {
        startTime: "09:00",
        endTime: "17:00",
        days: [
            "2020-11-06",
            "2020-11-07",
            "2020-11-08",
            "2020-11-09",
            "2020-11-10",
            "2020-11-11",
            "2020-11-12"
        ],
        currentWeek: 1
    };

    const query = {
        participants: [
            {
                required: "all",
                members: [{ sub: "SUB" }]
            }
        ],
        required_duration: { minutes: 60 }
    };

    it("correctly crops a single overlapping period", () => {
        const input = {
            ...query,
            available_periods: [
                { start: "2020-11-09T06:00:00Z", end: "2020-11-09T19:00:00Z" }
            ]
        };
        const out = [
            { start: "2020-11-09T09:00:00Z", end: "2020-11-09T17:00:00Z" }
        ];
        expect(utils.cropQuery(input, cropExtent).available_periods).toEqual(
            out
        );
    });

    it("correctly crops multiple overlapping periods", () => {
        const input = {
            ...query,
            available_periods: [
                { start: "2020-11-09T06:00:00Z", end: "2020-11-09T19:00:00Z" },
                { start: "2020-11-10T06:00:00Z", end: "2020-11-10T12:00:00Z" },
                { start: "2020-11-11T06:00:00Z", end: "2020-11-11T19:00:00Z" }
            ]
        };
        const out = [
            { start: "2020-11-09T09:00:00Z", end: "2020-11-09T17:00:00Z" },
            { start: "2020-11-10T09:00:00Z", end: "2020-11-10T12:00:00Z" },
            { start: "2020-11-11T09:00:00Z", end: "2020-11-11T17:00:00Z" }
        ];
        expect(utils.cropQuery(input, cropExtent).available_periods).toEqual(
            out
        );
    });

    it("correctly crops huge overlapping periods", () => {
        const input = {
            ...query,
            available_periods: [
                { start: "2020-10-09T06:00:00Z", end: "2020-12-09T19:00:00Z" }
            ]
        };
        const out = [
            { start: "2020-11-06T09:00:00Z", end: "2020-11-06T17:00:00Z" },
            { start: "2020-11-07T09:00:00Z", end: "2020-11-07T17:00:00Z" },
            { start: "2020-11-08T09:00:00Z", end: "2020-11-08T17:00:00Z" },
            { start: "2020-11-09T09:00:00Z", end: "2020-11-09T17:00:00Z" },
            { start: "2020-11-10T09:00:00Z", end: "2020-11-10T17:00:00Z" },
            { start: "2020-11-11T09:00:00Z", end: "2020-11-11T17:00:00Z" },
            { start: "2020-11-12T09:00:00Z", end: "2020-11-12T17:00:00Z" }
        ];
        expect(utils.cropQuery(input, cropExtent).available_periods).toEqual(
            out
        );
    });

    it("correctly crops tiny overlapping periods", () => {
        const input = {
            ...query,
            available_periods: [
                { start: "2020-11-09T07:00:00Z", end: "2020-11-09T10:00:00Z" },
                { start: "2020-11-09T12:00:00Z", end: "2020-11-09T14:00:00Z" },
                { start: "2020-11-09T16:00:00Z", end: "2020-11-09T22:00:00Z" }
            ]
        };
        const out = [
            { start: "2020-11-09T09:00:00Z", end: "2020-11-09T10:00:00Z" },
            { start: "2020-11-09T12:00:00Z", end: "2020-11-09T14:00:00Z" },
            { start: "2020-11-09T16:00:00Z", end: "2020-11-09T17:00:00Z" }
        ];
        expect(utils.cropQuery(input, cropExtent).available_periods).toEqual(
            out
        );
    });

    it("correctly crops non-overlapping periods", () => {
        const input = {
            ...query,
            available_periods: [
                { start: "2020-11-09T07:00:00Z", end: "2020-11-09T12:00:00Z" },
                { start: "2020-11-10T12:00:00Z", end: "2020-11-10T14:00:00Z" },
                { start: "2020-11-11T16:00:00Z", end: "2020-11-11T13:00:00Z" }
            ]
        };
        const offsetCropExtent = {
            ...cropExtent,
            startTime: "15:00",
            endTime: "17:00"
        };
        expect(
            utils.cropQuery(input, offsetCropExtent).available_periods
        ).toEqual([]);
    });

    it("correctly crops non-overlapping but abutting periods", () => {
        const input = {
            ...query,
            available_periods: [
                { start: "2020-11-09T07:00:00Z", end: "2020-11-09T15:00:00Z" }
            ]
        };
        const offsetCropExtent = {
            ...cropExtent,
            startTime: "15:00",
            endTime: "17:00"
        };
        expect(
            utils.cropQuery(input, offsetCropExtent).available_periods
        ).toEqual([]);
    });

    // periodOverlap
    it("correctly detects overlaps", () => {
        const period_1 = {
            start: moment.utc("2020-11-09T09:00:00Z"),
            end: moment.utc("2020-11-09T12:00:00Z")
        };
        const period_2 = {
            start: moment.utc("2020-11-09T11:00:00Z"),
            end: moment.utc("2020-11-09T17:00:00Z")
        };
        const out = {
            start: "2020-11-09T11:00:00Z",
            end: "2020-11-09T12:00:00Z"
        };
        expect(utils.periodOverlap(period_1, period_2)).toEqual(out);
    });
    it("correctly detects internal overlaps", () => {
        const period_1 = {
            start: moment.utc("2020-11-09T09:00:00Z"),
            end: moment.utc("2020-11-09T17:00:00Z")
        };
        const period_2 = {
            start: moment.utc("2020-11-09T11:00:00Z"),
            end: moment.utc("2020-11-09T13:00:00Z")
        };
        const out = {
            start: "2020-11-09T11:00:00Z",
            end: "2020-11-09T13:00:00Z"
        };
        expect(utils.periodOverlap(period_1, period_2)).toEqual(out);
    });

    // divideDaysIntoWeeks
    it("correctly divides days into weeks", () => {
        const days = [
            "2020-11-06",
            "2020-11-07",
            "2020-11-08",
            "2020-11-09",
            "2020-11-10",
            "2020-11-11",
            "2020-11-12",
            "2020-11-13",
            "2020-11-14",
            "2020-11-15",
            "2020-11-16",
            "2020-11-17",
            "2020-11-18",
            "2020-11-19",
            "2020-11-20",
            "2020-11-21",
            "2020-11-22",
            "2020-11-23",
            "2020-11-24",
            "2020-11-25",
            "2020-11-26"
        ];
        const week_1 = [
            "2020-11-06",
            "2020-11-07",
            "2020-11-08",
            "2020-11-09",
            "2020-11-10",
            "2020-11-11",
            "2020-11-12"
        ];
        const week_2 = [
            "2020-11-13",
            "2020-11-14",
            "2020-11-15",
            "2020-11-16",
            "2020-11-17",
            "2020-11-18",
            "2020-11-19"
        ];
        const week_3 = [
            "2020-11-20",
            "2020-11-21",
            "2020-11-22",
            "2020-11-23",
            "2020-11-24",
            "2020-11-25",
            "2020-11-26"
        ];
        expect(utils.divideDaysIntoWeeks(days, 1)).toEqual(week_1);
        expect(utils.divideDaysIntoWeeks(days, 2)).toEqual(week_2);
        expect(utils.divideDaysIntoWeeks(days, 3)).toEqual(week_3);
    });

    // generateStaticWeeks
    it("correctly generates static weeks", () => {
        const input = [
            { start: "2020-11-09T06:00:00Z", end: "2020-11-09T19:00:00Z" },
            { start: "2020-11-10T06:00:00Z", end: "2020-11-10T12:00:00Z" },
            { start: "2020-11-11T06:00:00Z", end: "2020-11-11T19:00:00Z" }
        ];
        const out = {
            current: 1,
            days: [
                "2020-11-08",
                "2020-11-09",
                "2020-11-10",
                "2020-11-11",
                "2020-11-12",
                "2020-11-13",
                "2020-11-14"
            ],
            set: true,
            total: 1
        };
        expect(utils.generateStaticWeeks(input)).toEqual(out);
    });
    it("correctly generates multiple static weeks", () => {
        const input = [
            { start: "2020-11-09T06:00:00Z", end: "2020-11-09T19:00:00Z" },
            { start: "2020-11-10T06:00:00Z", end: "2020-11-10T12:00:00Z" },
            { start: "2020-11-11T06:00:00Z", end: "2020-11-11T19:00:00Z" },
            { start: "2020-11-22T06:00:00Z", end: "2020-11-23T19:00:00Z" }
        ];
        const out = {
            current: 1,
            days: [
                "2020-11-08",
                "2020-11-09",
                "2020-11-10",
                "2020-11-11",
                "2020-11-12",
                "2020-11-13",
                "2020-11-14",
                "2020-11-15",
                "2020-11-16",
                "2020-11-17",
                "2020-11-18",
                "2020-11-19",
                "2020-11-20",
                "2020-11-21",
                "2020-11-22",
                "2020-11-23",
                "2020-11-24",
                "2020-11-25",
                "2020-11-26",
                "2020-11-27",
                "2020-11-28"
            ],
            set: true,
            total: 3
        };
        expect(utils.generateStaticWeeks(input)).toEqual(out);
    });
    it("correctly generates static week from same-day start", () => {
        const input = [
            { start: "2019-11-11T06:00:00Z", end: "2019-11-11T19:00:00Z" },
            { start: "2019-11-12T06:00:00Z", end: "2019-11-12T19:00:00Z" },
            { start: "2019-11-13T06:00:00Z", end: "2019-11-13T19:00:00Z" },
            { start: "2019-11-14T06:00:00Z", end: "2019-11-14T19:00:00Z" }
        ];
        const out = {
            current: 1,
            days: [
                "2019-11-10",
                "2019-11-11",
                "2019-11-12",
                "2019-11-13",
                "2019-11-14",
                "2019-11-15",
                "2019-11-16"
            ],
            set: true,
            total: 1
        };
        expect(moment().utcOffset()).toEqual(0);
        expect(utils.generateStaticWeeks(input)).toEqual(out);
    });

    // getAllWeekDays
    it("gets all days between 2 dates", () => {
        const out = [
            "2020-03-01",
            "2020-03-02",
            "2020-03-03",
            "2020-03-04",
            "2020-03-05",
            "2020-03-06",
            "2020-03-07"
        ];
        expect(utils.getAllWeekDays("2020-03-01", "2020-03-05")).toEqual(out);
    });

    // getWeeksInfo
    it("gets week's info", () => {
        const input = [
            "2020-03-01",
            "2020-03-02",
            "2020-03-03",
            "2020-03-04",
            "2020-03-05",
            "2020-03-06",
            "2020-03-07"
        ];
        const out = {
            current: 1,
            days: [
                "2020-03-01",
                "2020-03-02",
                "2020-03-03",
                "2020-03-04",
                "2020-03-05",
                "2020-03-06",
                "2020-03-07"
            ],
            set: true,
            total: 1
        };
        expect(utils.getWeeksInfo(input)).toEqual(out);
    });

    // getDaysForWeek
    it("correctly generates a week of days from a single date", () => {
        const input = moment.utc("2020-05-12");
        const out = [
            "2020-05-12",
            "2020-05-13",
            "2020-05-14",
            "2020-05-15",
            "2020-05-16",
            "2020-05-17",
            "2020-05-18"
        ];
        expect(utils.getDaysForWeek(input)).toEqual(out);
    });

    // buildDayPeriod = (startTime, endTime, day)
    it("builds a day period", () => {
        const input = ["09:00", "17:00", "2020-03-20", "Etc/UTC"];
        const out = {
            start: "2020-03-20T09:00:00Z",
            end: "2020-03-20T17:00:00Z"
        };
        expect(moment().utcOffset()).toEqual(0);
        expect(utils.buildDayPeriod(...input)).toEqual(out);
    });

    // getMinMaxDates
    it("gets min/max dates from a query", () => {
        const input = {
            "2020-11-06T09:00:00Z": {
                start: "2020-11-06T09:00:00Z",
                end: "2020-11-06T17:00:00Z"
            },
            "2020-11-07T09:00:00Z": {
                start: "2020-11-07T09:00:00Z",
                end: "2020-11-07T17:00:00Z"
            },
            "2020-11-08T09:00:00Z": {
                start: "2020-11-08T09:00:00Z",
                end: "2020-11-08T17:00:00Z"
            },
            "2020-11-09T09:00:00Z": {
                start: "2020-11-09T09:00:00Z",
                end: "2020-11-09T17:00:00Z"
            },
            "2020-11-10T09:00:00Z": {
                start: "2020-11-10T09:00:00Z",
                end: "2020-11-10T17:00:00Z"
            },
            "2020-11-11T09:00:00Z": {
                start: "2020-11-11T09:00:00Z",
                end: "2020-11-11T17:00:00Z"
            },
            "2020-11-12T09:00:00Z": {
                start: "2020-11-12T09:00:00Z",
                end: "2020-11-12T17:00:00Z"
            }
        };
        const out = { min: "2020-11-06", max: "2020-11-12" };
        expect(utils.getMinMaxDates(input)).toEqual(out);
    });
    it("gets min/max dates from an empty query", () => {
        const out = {
            min: moment().format("YYYY-MM-DD"),
            max: moment()
                .add(1, "days")
                .format("YYYY-MM-DD")
        };
        expect(utils.getMinMaxDates()).toEqual(out);
    });

    it("checks visibility status", () => {
        const emptySlots = [
            {
                day: "2019-09-29",
                slots: [
                    {
                        start: "2019-09-29T09:00:00Z",
                        end: "2019-09-29T09:15:00Z"
                    },
                    {
                        start: "2019-09-29T09:15:00Z",
                        end: "2019-09-29T09:30:00Z"
                    },
                    {
                        start: "2019-09-29T09:30:00Z",
                        end: "2019-09-29T09:45:00Z"
                    },
                    {
                        start: "2019-09-29T09:45:00Z",
                        end: "2019-09-29T10:00:00Z"
                    }
                ]
            }
        ];
        const availablePeriods = {
            "2019-09-29T09:30:00Z": {
                start: "2019-09-29T09:30:00Z",
                end: "2019-09-29T10:30:00Z",
                participants: ["PARTICIPANT_1", "PARTICIPANT_2"]
            },
            "2019-09-29T09:45:00Z": {
                start: "2019-09-29T09:45:00Z",
                end: "2019-09-29T10:45:00Z",
                participants: ["PARTICIPANT_1", "PARTICIPANT_2"]
            },
            "2019-09-29T10:00:00Z": {
                start: "2019-09-29T10:00:00Z",
                end: "2019-09-29T11:00:00Z",
                participants: ["PARTICIPANT_1", "PARTICIPANT_2"]
            }
        };
        const input = [emptySlots, availablePeriods, 60, 15, false];
        const checkedSlots = utils.checkWeekdaysSlotAvailability(...input);
        expect(checkedSlots[0].day).toEqual("2019-09-29");
        expect(checkedSlots[0].slots.length).toEqual(4);
        expect(checkedSlots[0].slots[0].available).toEqual(false);
        expect(checkedSlots[0].slots[1].available).toEqual(false);
        expect(checkedSlots[0].slots[2].available).toEqual(true);
        expect(checkedSlots[0].slots[3].available).toEqual(true);
    });

    it("checks visibility status with overlap", () => {
        const emptySlots = [
            {
                day: "2019-09-29",
                slots: [
                    {
                        start: "2019-09-29T09:00:00Z",
                        end: "2019-09-29T09:15:00Z"
                    },
                    {
                        start: "2019-09-29T09:15:00Z",
                        end: "2019-09-29T09:30:00Z"
                    },
                    {
                        start: "2019-09-29T09:30:00Z",
                        end: "2019-09-29T09:45:00Z"
                    },
                    {
                        start: "2019-09-29T09:45:00Z",
                        end: "2019-09-29T10:00:00Z"
                    },
                    {
                        start: "2019-09-29T10:00:00Z",
                        end: "2019-09-29T10:15:00Z"
                    },
                    {
                        start: "2019-09-29T10:15:00Z",
                        end: "2019-09-29T10:30:00Z"
                    },
                    {
                        start: "2019-09-29T10:30:00Z",
                        end: "2019-09-29T10:45:00Z"
                    },
                    {
                        start: "2019-09-29T10:45:00Z",
                        end: "2019-09-29T11:00:00Z"
                    }
                ]
            }
        ];
        const availablePeriods = {
            "2019-09-29T09:30:00Z": {
                start: "2019-09-29T09:30:00Z",
                end: "2019-09-29T10:30:00Z",
                participants: ["PARTICIPANT_1", "PARTICIPANT_2"]
            }
        };
        const input = [emptySlots, availablePeriods, 60, 15, false];
        const checkedSlots = utils.checkWeekdaysSlotAvailability(...input);
        expect(checkedSlots[0].day).toEqual("2019-09-29");
        expect(checkedSlots[0].slots.length).toEqual(8);
        expect(checkedSlots[0].slots[1].available).toEqual(false);
        expect(checkedSlots[0].slots[2].available).toEqual(true);
        expect(checkedSlots[0].slots[3].available).toEqual(false);
        expect(checkedSlots[0].slots[2].target).toEqual(false);
        expect(checkedSlots[0].slots[3].target).toEqual("2019-09-29T09:30:00Z");
        expect(checkedSlots[0].slots[3].targetOffset).toEqual(3);
        expect(checkedSlots[0].slots[4].target).toEqual("2019-09-29T09:30:00Z");
        expect(checkedSlots[0].slots[4].targetOffset).toEqual(2);
        expect(checkedSlots[0].slots[5].target).toEqual("2019-09-29T09:30:00Z");
        expect(checkedSlots[0].slots[5].targetOffset).toEqual(1);
        expect(checkedSlots[0].slots[6].target).toEqual(false);
    });
});
