import moment from "moment-timezone";

import { parseAgendaOptions } from "../src/js/helpers/init.Agenda";
import { parseAvailabilityRulesOptions } from "../src/js/helpers/init.AvailabilityRules";
import { parseAvailabilityViewerOptions } from "../src/js/helpers/init.AvailabilityViewer";
import { parseCalendarSyncOptions } from "../src/js/helpers/init.CalendarSync";
import { parseSlotPickerOptions } from "../src/js/helpers/init.SlotPicker";

// The parsers rely on console warning and errors to
// comunicate problems to the users
console.error = jest.fn();
console.warn = jest.fn();

beforeEach(() => {
    console.error.mockClear();
    console.warn.mockClear();
});

describe("Parsing Agenda options", () => {
    it("works when all options are declared", () => {
        const input = {
            data_center: "de",
            target_id: "TARGET",
            element_token: "TOKEN"
        };
        const expectedOutput = {
            data_center: "de",
            domains: {
                apiDomain: "https://api-de.cronofy.com",
                appDomain: "https://app-de.cronofy.com"
            },
            target: "TARGET",
            token: "TOKEN"
        };
        const result = parseAgendaOptions(input);
        expect(result.data_center).toEqual(expectedOutput.data_center);
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(result.target).toEqual(expectedOutput.target);
        expect(result.token).toEqual(expectedOutput.token);
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("fails if there is no token declared", () => {
        expect(parseAgendaOptions()).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("continues if there is no token declared, but we're in demo mode", () => {
        const expectedOutput = {
            demo: true,
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            target: "cronofy-element-agenda",
            token: false
        };
        const result = parseAgendaOptions({ demo: true });
        expect(result.demo).toEqual(expectedOutput.demo);
        expect(result.token).toEqual(expectedOutput.token);
        expect(console.warn).toHaveBeenCalledTimes(2);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default target if there is no target option", () => {
        const expectedOutput = {
            target: "cronofy-element-agenda",
            token: "TOKEN",
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            }
        };
        const result = parseAgendaOptions({ element_token: "TOKEN" });
        expect(result.target).toEqual(expectedOutput.target);
        expect(console.warn).toHaveBeenCalledTimes(1);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default api_domain if there is no api_domain option", () => {
        const expectedOutput = {
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            target: "TARGET",
            token: "TOKEN"
        };
        const result = parseAgendaOptions({
            element_token: "TOKEN",
            target_id: "TARGET"
        });
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });
});

describe("Parsing SlotPicker options", () => {
    it("works when all options are declared", () => {
        const input = {
            target_id: "TARGET",
            element_token: "TOKEN",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            }
        };

        const result = parseSlotPickerOptions(input);
        expect(result.config).toEqual({
            mode: "confirm",
            logs: "warn"
        });
        expect(result.domains).toEqual({
            apiDomain: "https://api.cronofy.com",
            appDomain: "https://app.cronofy.com"
        });
        expect(result.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(result.target).toEqual("TARGET");
        expect(result.token).toEqual("TOKEN");
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("fails if there is no token declared", () => {
        expect(parseSlotPickerOptions()).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("continues if there is no token declared, but we're in demo mode", () => {
        const expectedOutput = {
            config: {
                mode: "confirm",
                logs: "warn"
            },
            demo: true,
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            query: { available_periods: "TEST", required_duration: "TEST" },
            target: "cronofy-element-slot-picker",
            token: false
        };
        const result = parseSlotPickerOptions({
            demo: true,
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            }
        });
        expect(result.config).toEqual(expectedOutput.config);
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(result.target).toEqual(expectedOutput.target);
        expect(console.warn).toHaveBeenCalledTimes(2);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default target if there is no target option", () => {
        expect(
            parseSlotPickerOptions({
                availability_query: {
                    available_periods: "TEST",
                    required_duration: "TEST"
                },
                element_token: "TOKEN"
            }).target
        ).toEqual("cronofy-element-slot-picker");
        expect(console.warn).toHaveBeenCalledTimes(1);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default domains if there is no data_center option", () => {
        expect(
            parseSlotPickerOptions({
                availability_query: {
                    available_periods: "TEST",
                    required_duration: "TEST"
                },
                element_token: "TOKEN",
                target_id: "TARGET"
            }).domains
        ).toEqual({
            apiDomain: "https://api.cronofy.com",
            appDomain: "https://app.cronofy.com"
        });
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("creates correct domains if there is a data_center option", () => {
        expect(
            parseSlotPickerOptions({
                availability_query: {
                    available_periods: "TEST",
                    required_duration: "TEST"
                },
                data_center: "de",
                element_token: "TOKEN",
                target_id: "TARGET"
            }).domains
        ).toEqual({
            apiDomain: "https://api-de.cronofy.com",
            appDomain: "https://app-de.cronofy.com"
        });
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });
});

describe("Parsing AvailabilityViewer options", () => {
    const sniffedTimezone = moment.tz.guess();

    it("works when all options are declared", () => {
        const input = {
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: {
                bounds_control: true,
                start_time: "01:00",
                end_time: "02:00",
                week_start_day: "monday"
            },
            data_center: "DATA_CENTER",
            element_token: "TOKEN",
            target_id: "TARGET",
            tzid: "CUSTOM_TIME_ZONE"
        };
        const expectedOutput = {
            config: {
                boundsControl: true,
                mode: "confirm",
                logs: "warn",
                slot_selection: "available",
                start_time: "01:00",
                end_time: "02:00",
                startDay: "monday"
            },
            customtzid: true,
            data_center: "DATA_CENTER",
            domains: {
                apiDomain: "https://api-DATA_CENTER.cronofy.com",
                appDomain: "https://app-DATA_CENTER.cronofy.com"
            },
            error: false,
            query: { available_periods: "TEST", required_duration: "TEST" },
            target: "TARGET",
            token: "TOKEN",
            tzid: "CUSTOM_TIME_ZONE"
        };
        const result = parseAvailabilityViewerOptions(input);
        expect(result.config).toEqual(expectedOutput.config);
        expect(result.customtzid).toEqual(expectedOutput.customtzid);
        expect(result.data_center).toEqual(expectedOutput.data_center);
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(result.error).toEqual(expectedOutput.error);
        expect(result.query).toEqual(expectedOutput.query);
        expect(result.target).toEqual(expectedOutput.target);
        expect(result.token).toEqual(expectedOutput.token);
        expect(result.tzid).toEqual(expectedOutput.tzid);
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("returns an error if there is no query present when all other required options are declared", () => {
        const input = {
            element_token: "TOKEN",
            target_id: "TARGET",
            tzid: "CUSTOM_TIME_ZONE",
            config: { start_time: "01:00", end_time: "02:00" }
        };

        const output = parseAvailabilityViewerOptions(input);

        expect(console.error).toHaveBeenCalledTimes(1);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("fails if there is no token declared", () => {
        expect(parseAvailabilityViewerOptions()).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("continues if there is no token declared, but we're in demo mode", () => {
        const output = parseAvailabilityViewerOptions({
            demo: true,
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: { start_time: "01:00", end_time: "02:00" }
        });

        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.token).toEqual(false);
        expect(output.target).toEqual("cronofy-element-availability-viewer");
        expect(output.tzid).toEqual(sniffedTimezone);

        expect(console.warn).toHaveBeenCalledTimes(2);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default target if there is no target option", () => {
        const output = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: { start_time: "01:00", end_time: "02:00" }
        });
        expect(output.token).toEqual("TOKEN");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.target).toEqual("cronofy-element-availability-viewer");
        expect(console.warn).toHaveBeenCalledTimes(1);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default domains if there is no data_center option", () => {
        const expectedDomains = {
            apiDomain: "https://api.cronofy.com",
            appDomain: "https://app.cronofy.com"
        };

        const output = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            target_id: "TARGET",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: { start_time: "01:00", end_time: "02:00" }
        });
        expect(output.token).toEqual("TOKEN");
        expect(output.target).toEqual("TARGET");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.domains).toEqual(expectedDomains);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("creates correct domains if there is a data_center option", () => {
        const expectedDomains = {
            apiDomain: "https://api-de.cronofy.com",
            appDomain: "https://app-de.cronofy.com"
        };

        const output = parseAvailabilityViewerOptions({
            data_center: "de",
            element_token: "TOKEN",
            target_id: "TARGET",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: { start_time: "01:00", end_time: "02:00" }
        });
        expect(output.token).toEqual("TOKEN");
        expect(output.target).toEqual("TARGET");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.domains).toEqual(expectedDomains);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses the config.mode", () => {
        const output = parseAvailabilityViewerOptions({
            data_center: "de",
            element_token: "TOKEN",
            target_id: "TARGET",
            config: {
                mode: "multi_select",
                start_time: "01:00",
                end_time: "02:00"
            },
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            }
        });

        expect(output.token).toEqual("TOKEN");
        expect(output.target).toEqual("TARGET");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.config.mode).toEqual("multi_select");
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses an empty config.mode", () => {
        const output = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            target_id: "TARGET",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: { start_time: "01:00", end_time: "02:00" }
        });

        expect(output.token).toEqual("TOKEN");
        expect(output.target).toEqual("TARGET");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.config.mode).toEqual("confirm");
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses the config.customBounds", () => {
        const output = parseAvailabilityViewerOptions({
            data_center: "de",
            element_token: "TOKEN",
            target_id: "TARGET",
            config: {
                bounds_control: true,
                start_time: "01:00",
                end_time: "02:00"
            },
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            }
        });

        expect(output.token).toEqual("TOKEN");
        expect(output.target).toEqual("TARGET");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.config.boundsControl).toEqual(true);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses an empty config.customBounds", () => {
        const output = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            target_id: "TARGET",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: { start_time: "01:00", end_time: "02:00" }
        });

        expect(output.token).toEqual("TOKEN");
        expect(output.target).toEqual("TARGET");
        expect(output.query).toEqual({
            available_periods: "TEST",
            required_duration: "TEST"
        });
        expect(output.config.boundsControl).toEqual(false);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses default config.slotSelection", () => {
        const defaultOutput = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            target_id: "TARGET",
            config: {
                slot_selection: "availability",
                start_time: "01:00",
                end_time: "02:00"
            },
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            }
        });

        expect(defaultOutput.config.slot_selection).toEqual("availability");
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses empty config.slotSelection", () => {
        const withoutSelection = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            target_id: "TARGET",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: {
                start_time: "01:00",
                end_time: "02:00"
            }
        });

        expect(withoutSelection.config.slot_selection).toEqual("available");
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses config.slotSelection", () => {
        const withSelection = parseAvailabilityViewerOptions({
            element_token: "TOKEN",
            target_id: "TARGET",
            config: {
                slot_selection: "restricted",
                start_time: "01:00",
                end_time: "02:00"
            },
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            }
        });

        expect(withSelection.config.slot_selection).toEqual("restricted");
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses tzid option", () => {
        const input = {
            data_center: "DATA_CENTER",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: {
                start_time: "01:00",
                end_time: "02:00"
            },
            target_id: "TARGET",
            element_token: "TOKEN",
            tzid: "CUSTOM_TIME_ZONE"
        };
        const result = parseAvailabilityViewerOptions(input);

        expect(result.customtzid).toEqual(true);
        expect(result.tzid).toEqual("CUSTOM_TIME_ZONE");
    });

    it("correctly adds a fallback tzid option", () => {
        const input = {
            data_center: "DATA_CENTER",
            availability_query: {
                available_periods: "TEST",
                required_duration: "TEST"
            },
            config: {
                start_time: "01:00",
                end_time: "02:00"
            },
            target_id: "TARGET",
            element_token: "TOKEN"
        };
        const result = parseAvailabilityViewerOptions(input);

        expect(result.customtzid).toEqual(false);
        expect(result.tzid).toEqual(sniffedTimezone);
    });
});

describe("Parsing AvailabilityRules options", () => {
    it("works when all options are declared", () => {
        const input = {
            config: {
                logs: "info",
                week_start_day: "monday"
            },
            data_center: "de",
            target_id: "TARGET",
            element_token: "TOKEN",
            availability_rule_id: "RULE_ID",
            tzid: "TZID"
        };
        const expectedOutput = {
            availability_rule_id: "RULE_ID",
            config: { logs: "info", startDay: "monday" },
            data_center: "de",
            domains: {
                apiDomain: "https://api-de.cronofy.com",
                appDomain: "https://app-de.cronofy.com"
            },
            error: false,
            target: "TARGET",
            token: "TOKEN",
            tzid: "TZID"
        };
        const result = parseAvailabilityRulesOptions(input);
        expect(result.availability_rule_id).toEqual(
            expectedOutput.availability_rule_id
        );
        expect(result.config).toEqual(expectedOutput.config);
        expect(result.data_center).toEqual(expectedOutput.data_center);
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(result.error).toEqual(expectedOutput.error);
        expect(result.target).toEqual(expectedOutput.target);
        expect(result.token).toEqual(expectedOutput.token);
        expect(result.tzid).toEqual(expectedOutput.tzid);
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("shows a warning if there is no availability_rule_id present when all other options are declared", () => {
        const input = {
            element_token: "TOKEN",
            target_id: "TARGET",
            tzid: "TZID"
        };
        parseAvailabilityRulesOptions(input);
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(1);
    });

    it("fails if there is no token declared", () => {
        expect(parseAvailabilityRulesOptions()).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("continues if there is no token declared, but we're in demo mode", () => {
        const expectedOutput = {
            availability_rule_id: "RULE_ID",
            config: {},
            demo: true,
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            error: false,
            target: "cronofy-element-availability-rules",
            token: false,
            tzid: "TZID"
        };
        const result = parseAvailabilityRulesOptions({
            demo: true,
            availability_rule_id: "RULE_ID",
            tzid: "TZID"
        });
        expect(result.demo).toEqual(expectedOutput.demo);
        expect(result.token).toEqual(expectedOutput.token);
        expect(console.warn).toHaveBeenCalledTimes(2);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default target if there is no target option", () => {
        const expectedOutput = {
            availability_rule_id: "RULE_ID",
            config: {},
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            error: false,
            target: "cronofy-element-availability-rules",
            token: "TOKEN",
            tzid: "TZID"
        };
        const result = parseAvailabilityRulesOptions({
            element_token: "TOKEN",
            availability_rule_id: "RULE_ID",
            tzid: "TZID"
        });
        expect(result.target).toEqual(expectedOutput.target);
        expect(console.warn).toHaveBeenCalledTimes(1);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default domains if there is no data_center option", () => {
        const expectedOutput = {
            availability_rule_id: "RULE_ID",
            config: {},
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            error: false,
            target: "TARGET",
            token: "TOKEN",
            tzid: "TZID"
        };
        const result = parseAvailabilityRulesOptions({
            availability_rule_id: "RULE_ID",
            element_token: "TOKEN",
            target_id: "TARGET",
            tzid: "TZID"
        });
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("creates correct domains if there is a data_center option", () => {
        const expectedOutput = {
            availability_rule_id: "RULE_ID",
            config: {},
            data_center: "de",
            domains: {
                apiDomain: "https://api-de.cronofy.com",
                appDomain: "https://app-de.cronofy.com"
            },
            error: false,
            target: "TARGET",
            token: "TOKEN",
            tzid: "TZID"
        };
        const result = parseAvailabilityRulesOptions({
            availability_rule_id: "RULE_ID",
            data_center: "de",
            element_token: "TOKEN",
            target_id: "TARGET",
            tzid: "TZID"
        });
        expect(result.domains).toEqual(expectedOutput.domains);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });
});

describe("Parsing CalendarSync options", () => {
    it("works when all required options are declared", () => {
        const input = {
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            data_center: "de",
            element_token: "TOKEN",
            target_id: "TARGET"
        };
        const expectedOutput = {
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            data_center: "de",
            domains: {
                apiDomain: "https://api-de.cronofy.com",
                appDomain: "https://app-de.cronofy.com"
            },
            error: false,
            target: "TARGET",
            token: "TOKEN"
        };
        const output = parseCalendarSyncOptions(input);

        expect(output.authorization).toEqual(expectedOutput.authorization);
        expect(output.domains).toEqual(expectedOutput.domains);
        expect(output.error).toEqual(false);
        expect(output.target).toEqual("TARGET");
        expect(output.token).toEqual("TOKEN");
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("does not fail even if there is no token declared", () => {
        const expectedOutput = {
            authorization: {
                client_id: "CLIENT_ID",
                redirect_uri: "REDIRECT_URI",
                scope: "SCOPE"
            },
            domains: {
                apiDomain: "https://api.cronofy.com",
                appDomain: "https://app.cronofy.com"
            },
            error: false,
            target: "TARGET",
            token: false
        };

        const output = parseCalendarSyncOptions({
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            target_id: "TARGET"
        });

        expect(output.authorization).toEqual(expectedOutput.authorization);
        expect(output.domains).toEqual(expectedOutput.domains);
        expect(output.error).toEqual(false);
        expect(output.target).toEqual("TARGET");
        expect(output.token).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(0);
        expect(console.warn).toHaveBeenCalledTimes(0);
    });

    it("fails if there is no authorization option", () => {
        expect(
            parseCalendarSyncOptions({
                target: "TARGET",
                token: "TOKEN"
            })
        ).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("fails if there is no authorization.redirect_uri option", () => {
        expect(
            parseCalendarSyncOptions({
                target: "TARGET",
                token: "TOKEN",
                authorization: {
                    client_id: "CLIENT_ID",
                    scope: "SCOPE"
                }
            })
        ).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("fails if there is no authorization.client_id option", () => {
        expect(
            parseCalendarSyncOptions({
                target: "TARGET",
                token: "TOKEN",
                authorization: {
                    redirect_uri: "REDIRECT_URI",
                    scope: "SCOPE"
                }
            })
        ).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("fails if there is no authorization.scope option", () => {
        expect(
            parseCalendarSyncOptions({
                authorization: {
                    redirect_uri: "REDIRECT_URI",
                    client_id: "CLIENT_ID"
                },
                target: "TARGET",
                token: "TOKEN"
            })
        ).toEqual(false);
        expect(console.error).toHaveBeenCalledTimes(1);
    });

    it("continues if there is no token declared, but we're in demo mode", () => {
        const expectedAuthorization = {
            redirect_uri: "REDIRECT_URI",
            client_id: "CLIENT_ID",
            scope: "SCOPE"
        };

        const output = parseCalendarSyncOptions({
            demo: true
        });
        expect(output.authorization).toEqual(expectedAuthorization);
        expect(output.demo).toEqual(true);
        expect(console.warn).toHaveBeenCalledTimes(2);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default target if there is no target option", () => {
        const output = parseCalendarSyncOptions({
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            element_token: "TOKEN"
        });

        expect(output.target).toEqual("cronofy-element-calendar-sync");
        expect(console.warn).toHaveBeenCalledTimes(1);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("applies the default domains if there is no data_center option", () => {
        const expectedDomains = {
            apiDomain: "https://api.cronofy.com",
            appDomain: "https://app.cronofy.com"
        };
        const output = parseCalendarSyncOptions({
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            element_token: "TOKEN",
            target_id: "TARGET"
        });

        expect(output.domains).toEqual(expectedDomains);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("creates correct domains if there is a data_center option", () => {
        const expectedDomains = {
            apiDomain: "https://api-de.cronofy.com",
            appDomain: "https://app-de.cronofy.com"
        };
        const output = parseCalendarSyncOptions({
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            data_center: "de",
            element_token: "TOKEN",
            target_id: "TARGET"
        });
        expect(output.domains).toEqual(expectedDomains);
        expect(output.data_center).toEqual("de");
        expect(output.error).toEqual(false);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly parses singleProfile option", () => {
        const output = parseCalendarSyncOptions({
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            single_profile: true,
            element_token: "TOKEN",
            target_id: "TARGET"
        });
        expect(output.single_profile).toEqual(true);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });

    it("correctly applies default for singleProfile option", () => {
        const output = parseCalendarSyncOptions({
            authorization: {
                redirect_uri: "REDIRECT_URI",
                client_id: "CLIENT_ID",
                scope: "SCOPE"
            },
            element_token: "TOKEN",
            target_id: "TARGET"
        });
        expect(output.single_profile).toEqual(false);
        expect(console.warn).toHaveBeenCalledTimes(0);
        expect(console.error).toHaveBeenCalledTimes(0);
    });
});
