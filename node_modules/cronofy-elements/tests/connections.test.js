// import fetchMock from "fetch-mock";
import * as connections from "../src/js/helpers/connections";

// Test data:
const exampleOptions = ["TOKEN_EXAMPLE", "http://local.cronofy.com"];
const calendarResponse = {
    calendars: [
        {
            provider_name: "google",
            profile_id: "A_PROFILE_ID",
            profile_name: "AN_EMAIL_ADDRESS",
            calendar_id: "A_CALENDAR_ID_0",
            calendar_name: "AN_EMAIL_ADDRESS",
            calendar_readonly: false,
            calendar_deleted: false,
            calendar_primary: true,
            permission_level: "sandbox"
        },
        {
            provider_name: "google",
            profile_id: "A_PROFILE_ID",
            profile_name: "AN_EMAIL_ADDRESS",
            calendar_id: "A_CALENDAR_ID_1",
            calendar_name: "A_TEST_NAME",
            calendar_readonly: false,
            calendar_deleted: false,
            calendar_primary: false,
            permission_level: "sandbox"
        }
    ]
};
const getInfoResponse = {
    sub: "acc_01234567890",
    email: "AN_EMAIL_ADDRESS",
    name: "PROFILE_NAME",
    zoneinfo: "Europe/London",
    "cronofy.type": "account",
    "cronofy.data": {
        authorization: { scope: "read_write" },
        profiles: [
            {
                provider_name: "google",
                profile_id: "A_PROFILE_ID",
                profile_name: "AN_EMAIL_ADDRESS",
                profile_connected: true,
                profile_initial_sync_required: false,
                profile_calendars: [
                    {
                        calendar_id: "A_CALENDAR_ID_0",
                        calendar_name: "CALENDAR_NAME",
                        calendar_readonly: false,
                        calendar_deleted: false,
                        calendar_primary: true,
                        permission_level: "sandbox"
                    },
                    {
                        calendar_id: "A_CALENDAR_ID_1",
                        calendar_name: "SECOND_CALENDAR_NAME",
                        calendar_readonly: false,
                        calendar_deleted: false,
                        calendar_primary: false,
                        permission_level: "sandbox"
                    }
                ]
            }
        ]
    }
};

describe("Connections", () => {
    beforeEach(() => {
        fetch.resetMocks();
    });

    // parseCalendars
    it("parses calendar info", () => {
        const calendars = connections.parseCalendars(calendarResponse);
        // creates the correct length of array
        expect(calendars.length).toEqual(2);
        // sets the name correctly
        expect(calendars[0].name).toEqual("AN_EMAIL_ADDRESS");
        expect(calendars[1].name).toEqual("A_TEST_NAME");
        // sets the id correctly
        expect(calendars[0].id).toEqual("A_CALENDAR_ID_0");
        expect(calendars[1].id).toEqual("A_CALENDAR_ID_1");
        // sets the color correctly
        expect(calendars[0].color).toEqual(0);
        expect(calendars[1].color).toEqual(1);
    });

    // getUserInfo
    it("calls calendars endopoint correctly", async () => {
        const mockBody = { body: "working" };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections.getUserInfo(...exampleOptions).then(res => {
            expect(res).toEqual(mockBody);
        });

        // Calls once
        expect(fetch.mock.calls.length).toEqual(1);
        // constructs url properly
        expect(fetch.mock.calls[0][0].toString()).toEqual(
            `${exampleOptions[1]}/v1/userinfo?et=${exampleOptions[0]}`
        );
    });

    // getUserInfo
    it("handles failed fetch calendars request", async () => {
        const errorMessage = "fake error message";
        fetch.mockReject(new Error(errorMessage));

        // Converts successful response into JSON
        await connections.getUserInfo(...exampleOptions).catch(err => {
            expect(err.type).toEqual(401);
            expect(typeof err.message).toEqual("string");
        });
    });

    // parseUserInfoCalendars
    it("parses calendar info", () => {
        const calendars = connections.parseUserInfoCalendars(getInfoResponse);
        // creates the correct length of array
        expect(calendars.length).toEqual(2);
        // sets the name correctly
        expect(calendars[0].name).toEqual("CALENDAR_NAME");
        expect(calendars[1].name).toEqual("SECOND_CALENDAR_NAME");
        // sets the id correctly
        expect(calendars[0].id).toEqual("A_CALENDAR_ID_0");
        expect(calendars[1].id).toEqual("A_CALENDAR_ID_1");
        // sets the color correctly
        expect(calendars[0].color).toEqual(0);
        expect(calendars[1].color).toEqual(1);
    });

    // parseEventsArgs
    // Not needed right away, but will be useful when handling multiple specified calendars.
    it("parses event query args", () => {
        const rawArgs = {
            tzid: "TIMEZONE",
            include_managed: true,
            from: "FROM",
            to: "TO"
        };
        const args = connections.parseEventsArgs(rawArgs, exampleOptions[0]);
        expect(args.tzid).toEqual("TIMEZONE");
        expect(args.et).toEqual(exampleOptions[0]);
        expect(args.include_managed).toBe(true);
        expect(args.from).toEqual("FROM");
        expect(args.to).toEqual("TO");
    });

    // createEventsUrl
    it("creates url from params", () => {
        const api_domain = "http://local.cronofy.com";
        const data = {
            tzid: "Europe/London",
            include_managed: true,
            from: "2018-09-17",
            include_geo: true,
            to: "2018-09-18"
        };
        expect(
            connections.createEventsUrl(api_domain, data).toString()
        ).toEqual(
            "http://local.cronofy.com/v1/events?tzid=Europe%2FLondon&include_managed=true&from=2018-09-17&include_geo=true&to=2018-09-18"
        );
    });

    // getEvents
    it("calls events endpoint correctly", async () => {
        const mockBody = {
            events: [
                { event: 2, name: "testing" },
                { event: 3, name: "something else" },
                { event: 4, name: "another thing" }
            ],
            userinfo: getInfoResponse
        };
        const args = {
            tzid: "Europe/London",
            include_managed: true,
            from: "2018-09-17",
            include_geo: true,
            to: "2018-09-18"
        };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections.getEvents(...exampleOptions, args).then(res => {
            expect(res.events).toEqual(mockBody.events);
        });

        // Calls once
        expect(fetch.mock.calls.length).toEqual(1);
        // constructs url properly
        expect(fetch.mock.calls[0][0].toString()).toEqual(
            `${exampleOptions[1]}/v1/events?et=${exampleOptions[0]}&from=2018-09-17&include_geo=true&include_managed=true&include_userinfo=true&to=2018-09-18&tzid=Europe%2FLondon`
        );
        // // sends auth token correctly
        // expect(fetch.mock.calls[0][1].headers["Authorization"]).toEqual(
        //     `Bearer ${exampleOptions[0]}`
        // );
    });

    // getEvents
    it("handles empty event response correctly", async () => {
        const mockBody = {
            events: []
        };
        const args = {
            tzid: "Europe/London",
            include_managed: true,
            from: "2018-09-17",
            include_geo: true,
            to: "2018-09-18"
        };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections.getEvents(...exampleOptions, args).then(res => {
            expect(res.events).toEqual([]);
        });
    });

    // getEvents
    it("calls multi-page events endpoint correctly", async () => {
        const mockLoadNextPage = jest.fn((x, y, z) => {
            z.push({ event: 2, name: "testing" });
            return z;
        });
        const mockBody = {
            pages: { next_page: "NEXT_PAGE_URL" },
            events: [{ event: 1, name: "test" }]
        };
        const desiredResult = [
            { event: 1, name: "test" },
            { event: 2, name: "testing" }
        ];
        const args = {
            tzid: "Europe/London",
            include_managed: true,
            from: "2018-09-17",
            include_geo: true,
            to: "2018-09-18"
        };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections
            .getEvents(...exampleOptions, args, mockLoadNextPage)
            .then(res => {
                expect(res).toEqual(desiredResult);
            });

        // Calls once
        expect(fetch.mock.calls.length).toEqual(1);
        // Calls second page
        expect(mockLoadNextPage.mock.calls.length).toEqual(1);
        // // Calls second page with correct args
        // expect(loadNextPage).toBeCalledWith(
        //     exampleOptions[0],
        //     "NEXT_PAGE_URL",
        //     [{ event: 1, name: "test" }] // TODO: why does this arg show the second event already?
        // );
    });

    // getEvents
    it("handles failed fetch events request", async () => {
        const errorMessage = "fake error message";
        fetch.mockReject(new Error(errorMessage));

        const args = {
            tzid: "Europe/London",
            include_managed: true,
            from: "2018-09-17",
            include_geo: true,
            to: "2018-09-18"
        };

        // Converts successful response into JSON
        await connections.getEvents(...exampleOptions, args).catch(err => {
            expect(err.type).toEqual(401);
            // expect(err.message).toEqual(
            //     "There was a problem fetching data: check your element_token is valid"
            // );
            expect(typeof err.message).toEqual("string");
        });
    });

    // loadNextPage
    it("loads multiple pages", async () => {
        const startingArray = [{ event: 1, name: "test" }];
        const mockBody = {
            events: [
                { event: 2, name: "testing" },
                { event: 3, name: "something else" },
                { event: 4, name: "another thing" }
            ]
        };
        const desiredResult = [
            { event: 1, name: "test" },
            { event: 2, name: "testing" },
            { event: 3, name: "something else" },
            { event: 4, name: "another thing" }
        ];
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections
            .loadNextPage(
                exampleOptions[0],
                `http://local.cronofy.com/v1/events/pages/NEXT_PAGE`,
                startingArray
            )
            .then(res => {
                expect(res.events).toEqual(desiredResult);
            });
        // Calls once
        expect(fetch.mock.calls.length).toEqual(1);
    });

    // loadNextPage
    it("handles empty multiple-page response correctly", async () => {
        const mockBody = {
            events: []
        };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections
            .loadNextPage(
                exampleOptions[0],
                `http://local.cronofy.com/v1/events/pages/NEXT_PAGE`,
                []
            )
            .then(res => {
                expect(res.events).toEqual([]);
            });
    });

    // loadNextPage
    it("loads multiple pages recurrsively", async () => {
        const mockLoadNextPage = jest.fn((w, x, y, z) => {
            y.push({ event: 5, name: "test" });
            return { events: y, userinfo: z };
        });
        const startingArray = [{ event: 1, name: "test" }];
        const mockBody = {
            pages: { next_page: "NEXT_PAGE_URL" },
            events: [
                { event: 2, name: "testing" },
                { event: 3, name: "something else" },
                { event: 4, name: "another thing" }
            ]
        };
        const desiredResult = [
            { event: 1, name: "test" },
            { event: 2, name: "testing" },
            { event: 3, name: "something else" },
            { event: 4, name: "another thing" },
            { event: 5, name: "test" }
        ];
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections
            .loadNextPage(
                exampleOptions[0],
                `http://local.cronofy.com/v1/events/pages/NEXT_PAGE`,
                startingArray,
                {},
                mockLoadNextPage
            )
            .then(res => {
                expect(res.events).toEqual(desiredResult);
            });
        // Calls once
        expect(fetch.mock.calls.length).toEqual(1);
        // Calls second page
        expect(mockLoadNextPage.mock.calls.length).toEqual(1);
    });

    // loadNextPage
    it("handles failed fetch next-page request", async () => {
        const errorMessage = "fake error message";
        fetch.mockReject(new Error(errorMessage));

        // Converts successful response into JSON
        await connections
            .loadNextPage(
                exampleOptions[0],
                `http://local.cronofy.com/v1/events/pages/NEXT_PAGE`,
                []
            )
            .catch(err => {
                expect(err.type).toEqual(401);

                expect(typeof err.message).toEqual("string");
            });
    });

    // getAvailability
    it("calls availability endpoint correctly", async () => {
        const mockBody = {
            available_periods: [
                {
                    start: "2018-11-09T09:00:00Z",
                    end: "2018-11-09T10:00:00Z",
                    participants: [
                        {
                            sub: "acc_5b97a52a5c92eb0cc0400ffe"
                        }
                    ]
                },
                {
                    start: "2018-11-10T10:30:00Z",
                    end: "2018-11-10T11:30:00Z",
                    participants: [
                        {
                            sub: "test_busy_1130-1200_1445-1500"
                        }
                    ]
                },
                {
                    start: "2018-11-11T10:30:00Z",
                    end: "2018-11-11T11:30:00Z",
                    participants: [
                        {
                            sub: "acc_5b97a52a5c92eb0cc0400ffe"
                        },
                        {
                            sub: "test_busy_1000-1030_1430-1540_2200-0600"
                        },
                        {
                            sub: "test_busy_1130-1200_1445-1500"
                        }
                    ]
                }
            ]
        };
        const args = {
            participants: [
                {
                    required: "all",
                    members: [{ sub: "acc_5ba21743f408617d1269ea1e" }]
                }
            ],
            required_duration: { minutes: 30 },
            available_periods: [
                { start: "2018-12-09T09:00:00Z", end: "2018-12-09T17:00:00Z" },
                { start: "2018-12-10T09:00:00Z", end: "2018-12-10T17:00:00Z" },
                { start: "2018-12-11T09:00:00Z", end: "2018-12-11T17:00:00Z" }
            ]
        };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        // Converts successful response into JSON
        await connections.getAvailability(...exampleOptions, args).then(res => {
            expect(res).toEqual(mockBody);
        });

        // Calls once
        expect(fetch.mock.calls.length).toEqual(1);
        // constructs url properly
        expect(fetch.mock.calls[0][0].toString()).toEqual(
            `${exampleOptions[1]}/v1/availability?et=${exampleOptions[0]}`
        );

        expect(fetch.mock.calls[0][1].body).toEqual(JSON.stringify(args));
    });

    // getAvailability
    it("handles failed fetch availability request", async () => {
        const args = {
            participants: [
                {
                    required: "all",
                    members: [{ sub: "acc_5ba21743f408617d1269ea1e" }]
                }
            ],
            required_duration: { minutes: 30 },
            available_periods: [
                { start: "2018-12-09T09:00:00Z", end: "2018-12-09T17:00:00Z" },
                { start: "2018-12-10T09:00:00Z", end: "2018-12-10T17:00:00Z" },
                { start: "2018-12-11T09:00:00Z", end: "2018-12-11T17:00:00Z" }
            ]
        };

        fetch.mockReject(new Error("unknown error"));

        // Injects an error message
        await connections
            .getAvailability(...exampleOptions, args)
            .catch(err => {
                expect(typeof err.message).toEqual("string");
            });
    });

    // getAvailabilityRules
    it("handles fetch availability_rule request", async () => {
        const mockBody = {
            availability_rule: {
                availability_rule_id: "availability_rule_id",
                tzid: "Europe/London",
                weekly_periods: [{}, {}, {}, {}, {}]
            }
        };
        fetch.mockResponseOnce(JSON.stringify(mockBody));

        const res = await connections.getAvailabilityRules(
            ...exampleOptions,
            "availability_rule_id"
        );

        expect(res).toEqual(mockBody);
    });

    // getAvailabilityRules
    it("handles failed fetch availability_rule request", async () => {
        fetch.mockReject(new Error("unknown error"));

        // Injects an error message
        await connections
            .getAvailabilityRules(...exampleOptions, "availability_rule_id")
            .catch(err => {
                expect(typeof err.message).toEqual("string");
            });
    });

    // getAvailabilityRules
    it("handles unknown availability_rule requests", async () => {
        fetch.mockResponseOnce(JSON.stringify([]), { status: 404 });

        const res = await connections.getAvailabilityRules(
            ...exampleOptions,
            "availability_rule_id"
        );

        expect(res.type).toEqual(404);
    });
});
